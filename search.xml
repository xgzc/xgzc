<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【洛谷P4178】Tree]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90%E6%B4%9B%E8%B0%B7P4178%E3%80%91Tree%2F</url>
    <content type="text"><![CDATA[题面题解感觉和$CDQ$分治一样套路啊 首先，构建出点分树 对于每一层分治重心，求出它到子树中任意点的距离 然后$two-pointers$计算满足小于等于$K$的点对数目，加入答案 但是可能会算重，那么就减去子树内两两点之间的贡献即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));namespace IO&#123; const int BUFSIZE = 1 &lt;&lt; 20; char ibuf[BUFSIZE], *is = ibuf, *it = ibuf; inline char getchar() &#123; if (is == it) it = (is = ibuf) + fread(ibuf, 1, BUFSIZE, stdin); return *is++; &#125;&#125;inline int read()&#123; int data = 0, w = 1; char ch = IO::getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = IO::getchar(); if(ch == '-') w = -1, ch = IO::getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = IO::getchar(); return data*w;&#125;const int maxn(40010);struct edge &#123; int next, to, dis; &#125; e[maxn &lt;&lt; 1];int head[maxn], e_num, n, Size, Max, root, stk[maxn], dep[maxn], top, size[maxn], K, ans, vis[maxn];inline void add_edge(int from, int to, int dis) &#123; e[++e_num] = (edge) &#123;head[from], to, dis&#125;; head[from] = e_num; &#125;void GetRoot(int x, int fa)&#123; size[x] = 1; int max = 0; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(to == fa || vis[to]) continue; GetRoot(to, x); size[x] += size[to]; max = std::max(max, size[to]); &#125; max = std::max(max, Size - size[x]); if(max &lt; Max) Max = max, root = x;&#125;void GetDep(int x, int fa)&#123; stk[++top] = dep[x]; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(to == fa || vis[to]) continue; dep[to] = dep[x] + e[i].dis; GetDep(to, x); &#125;&#125;int Calc(int x, int pre)&#123; top = 0; dep[x] = pre; GetDep(x, 0); std::sort(stk + 1, stk + top + 1); int l = 1, r = top, sum = 0; while(l &lt; r) &#123; if(stk[l] + stk[r] &lt;= K) sum += r - l, ++l; else --r; &#125; return sum;&#125;void Solve(int x)&#123; ans += Calc(x, 0); vis[x] = 1; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(vis[to]) continue; ans -= Calc(to, e[i].dis); Size = Max = size[to]; GetRoot(to, x); Solve(root); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE file(cpp);#endif Max = Size = n = read(); for(RG int i = 1, a, b, c; i &lt; n; i++) a = read(), b = read(), c = read(), add_edge(a, b, c), add_edge(b, a, c); K = read(); GetRoot(1, 0); Solve(root); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷P4556】雨天的尾巴]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90%E6%B4%9B%E8%B0%B7P4556%E3%80%91%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4%2F</url>
    <content type="text"><![CDATA[题面题解线段树合并 我们看到这道题目首先可以想到树上差分，然后$dfs$合并 发现题目让我们求的东西很好用线段树维护 于是可以想到线段树合并 全世界只有我写指针版动态开点线段树（大雾 如果你要写指针版，请开内存池，new又耗时又浪费空间 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=data*10+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010);struct node &#123; node *son[2]; int max, id; &#125; *root[maxn], pool[maxn * 50], *pos;struct edge &#123; int next, to; &#125; e[maxn &lt;&lt; 1];struct query &#123; int next, to, id; &#125; q[maxn &lt;&lt; 1];struct answer &#123; int a, b, v, lca; &#125; ans[maxn];bool vis[maxn];int head[maxn], e_num, fa[maxn], n, m, s, qhead[maxn], q_num, F[maxn], Ans[maxn];inline void add_edge(int from, int to) &#123; e[++e_num] = (edge) &#123;head[from], to&#125;; head[from] = e_num; &#125;inline void add_query(int from, int to, int id) &#123; q[++q_num] = (query) &#123;qhead[from], to, id&#125;; qhead[from] = q_num; &#125;inline int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125;void dfs(int x)&#123; vis[x] = true; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(to == F[x]) continue; F[to] = x; dfs(to); fa[find(to)] = find(x); &#125; for(RG int i = qhead[x]; i; i = q[i].next) &#123; int to = q[i].to; if(!vis[to]) continue; ans[q[i].id].lca = find(to); &#125;&#125;inline int Max(node *x) &#123; return x ? x -&gt; max : 0; &#125;inline int Id(node *x) &#123; return x ? x -&gt; id : 0; &#125;inline void pushup(node *x)&#123; if(Max(x -&gt; son[0]) &gt;= Max(x -&gt; son[1])) x -&gt; max = Max(x -&gt; son[0]), x -&gt; id = Id(x -&gt; son[0]); else x -&gt; max = Max(x -&gt; son[1]), x -&gt; id = Id(x -&gt; son[1]); if(!x -&gt; max) x -&gt; id = 0;&#125;inline void Insert(node *&amp;x, int pos, int val, int l = 1, int r = maxn - 10)&#123; if(!x) x = ::pos++; if(l == r) &#123; x -&gt; max += val; x -&gt; id = l; if(!x -&gt; max) x -&gt; id = 0; return; &#125; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) Insert(x -&gt; son[0], pos, val, l, mid); else Insert(x -&gt; son[1], pos, val, mid + 1, r); pushup(x); if(!x -&gt; max) x -&gt; id = 0;&#125;inline node *Merge(node *x, node *&amp;y, int l = 1, int r = maxn - 10)&#123; if(!x) return y; if(!y) return x; int mid = (l + r) &gt;&gt; 1; if(l == r) &#123; x -&gt; max += y -&gt; max; x -&gt; id = l; return x; &#125; x -&gt; son[0] = Merge(x -&gt; son[0], y -&gt; son[0], l, mid); x -&gt; son[1] = Merge(x -&gt; son[1], y -&gt; son[1], mid + 1, r); pushup(x); return x;&#125;void solve(int x)&#123; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(to == F[x]) continue; solve(to); root[x] = Merge(root[x], root[to]); &#125; Ans[x] = Id(root[x]);&#125;int main()&#123;#ifndef ONLINE_JUDGE file(cpp);#endif pos = pool; n = read(); m = read(); for(RG int i = 1, a, b; i &lt; n; i++) a = read(), b = read(), add_edge(a, b), add_edge(b, a); for(RG int i = 1; i &lt;= n; i++) fa[i] = i; for(RG int i = 1, a, b, c; i &lt;= m; i++) a = read(), b = read(), c = read(), ans[i] = (answer) &#123;a, b, c, 0&#125;, add_query(a, b, i), add_query(b, a, i); dfs(1); for(RG int i = 1; i &lt;= m; i++) Insert(root[ans[i].a], ans[i].v, 1), Insert(root[ans[i].b], ans[i].v, 1), Insert(root[ans[i].lca], ans[i].v, -1), Insert(root[F[ans[i].lca]], ans[i].v, -1); solve(1); for(RG int i = 1; i &lt;= n; i++) printf("%d\n", Ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷P2252】取石子游戏]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90%E6%B4%9B%E8%B0%B7P2252%E3%80%91%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题面题解威佐夫博弈 代码1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define RG registerconst double Phi((sqrt(5) + 1.) / 2.);int a, b;inline int abs(int a) &#123; return a &lt; 0 ? a : -a; &#125;int main()&#123; while(~scanf("%d%d", &amp;a, &amp;b)) &#123; if(a &gt; b) std::swap(a, b); int c = abs(a - b) * Phi; if(c == a) puts("0"); else puts("1"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CTSC1997】选课]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90CTSC1997%E3%80%91%E9%80%89%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[题面题解树形背包板子题。 设$f[i][j]$表示在以$x$为根的子树选$j$门课（包括$x$）能够获得的最高学分，用分组背包转移即可。 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;vector&gt;#define RG registerinline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(310);std::vector&lt;int&gt; g[maxn];typedef std::vector&lt;int&gt;::iterator iter;int s[maxn], f[maxn][maxn], n, m;void dfs(int x)&#123; f[x][0] = 0; for(RG iter it = g[x].begin(); it != g[x].end(); ++it) &#123; int to = *it; dfs(to); for(RG int v = m + 1; v; --v) for(RG int j = 0; j &lt; v; ++j) f[x][v] = std::max(f[x][v], f[x][v - j] + f[to][j]); &#125;&#125;int main()&#123; n = read(); m = read(); for(RG int i = 1; i &lt;= n; i++) g[read()].push_back(i), f[i][1] = s[i] = read(); dfs(0); printf("%d\n", f[0][m + 1]); return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF535E】Tavas and Pashmaks]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90CF535E%E3%80%91-Tavas-and-Pashmaks%2F</url>
    <content type="text"><![CDATA[题面题解我们可以尝试寻找临界值。枚举，那么令$\frac{A}{a_i}+\frac{B}{b_i}=\frac{A}{a_j}+\frac{B}{b_j}$，如果这对$A,B$在$i,j$取到最值，那么$i,j$有用。 将每个型号看成平面上的点$(\frac1{a_i},\frac1{b_i})$，我们的问题变成了：给定任意$A,B$，最小化$z=Ax+By$（$x,y$即为点的坐标）。因为$A,B$为正实数,所以目标函数的斜率为负。于是，有用的点分布在该点集的左下凸包上。使用类似斜率优化的方法求出凸包即可。 时间复杂度$O(nlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(3e5 + 10);int q[maxn], top, next[maxn], ok[maxn], n;struct point &#123; int x, y, id; &#125; p[maxn];double k[maxn];inline bool operator &lt; (const point &amp;lhs, const point &amp;rhs)&#123; return lhs.x &gt; rhs.x || (lhs.x == rhs.x &amp;&amp; lhs.y &gt; rhs.y);&#125;inline double slope(const point &amp;i, const point &amp;j)&#123; return 1. * i.x * j.x * (j.y - i.y) / (1. * i.y * j.y * (j.x - i.x));&#125;int main()&#123; n = read(); int minx, miny = 0; for(RG int i = 1; i &lt;= n; i++) &#123; p[i] = (point) &#123;read(), read(), i&#125;; if(miny &lt; p[i].y || (miny == p[i].y &amp;&amp; minx &lt; p[i].x)) minx = p[i].x, miny = p[i].y; &#125; std::sort(p + 1, p + n + 1); q[top = 1] = 1; for(RG int i = 2; i &lt;= n &amp;&amp; minx &lt;= p[i].x; i++) &#123; if(p[q[top]].x == p[i].x) &#123; if(p[q[top]].y == p[i].y) next[p[i].id] = next[p[q[top]].id], next[p[q[top]].id] = p[i].id; continue; &#125; while(top &gt; 1 &amp;&amp; k[top] &gt; slope(p[q[top]], p[i])) --top; q[++top] = i; k[top] = slope(p[q[top - 1]], p[i]); &#125; for(RG int i = top; i; --i) for(RG int j = p[q[i]].id; j; j = next[j]) ok[j] = 1; for(RG int i = 1; i &lt;= n; i++) if(ok[i]) printf("%d ", i); return 0;&#125;]]></content>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-10-18考试]]></title>
    <url>%2F2018%2F10%2F20%2F2018-10-18%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[T1题面这是一道基础分治练习题。给你三个数列${a_i}, {b_i}, {c_i},$保证每个数列都恰好是一个排列。你需要求出满足$a_i &lt; a_j , b_i &lt;b_j , c_i &lt; c_j$的有序对$(i, j)$ 的数目。 题解一眼三维偏序模板，于是就打了暴力CDQ爆44… 不过这个题和普通的三维偏序模板有一些区别。 三个数列都是排列! 我们考虑计算下面三个东西。$$X = \sum_{i, j}[a_i &lt; a_j][b_i &lt; b_j] \Y = \sum_{i, j}[b_i &lt; b_j][c_i &lt; c_j] \Z = \sum_{i, j}[a_i &lt; a_j][c_i &lt; c_j]$$对于一对需要算答案的点对$(i, j),$它一定在$X, Y, Z$中都被算过一遍。对于不需要算答案的点对,它一定恰好在$X, Y, Z$中的一个里面被计算过一次。$$\therefore Ans = \frac{X+Y+Z-\binom{n}{2}}{2}$$ 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define RG registerconst int maxn(2e6 + 10);unsigned int SA, SB, SC;int n, a[maxn], b[maxn], c[maxn], C1[maxn], C2[maxn], C3[maxn];long long ans;struct qry &#123; int a, b, c; &#125; q[maxn];inline void swap(int &amp;x, int &amp;y) &#123; static int t; t = x; x = y; y = t; &#125;inline unsigned int Random()&#123; SA ^= SA &lt;&lt; 16; SA ^= SA &gt;&gt; 5; SA ^= SA &lt;&lt; 1; static unsigned int t; t = SA; SA = SB; SB = SC; SC ^= t ^ SA; return SC;&#125;inline void add(int *C, int x) &#123; while(x &lt;= n) ++C[x], x += x &amp; -x; &#125;inline int query(int *C, int x) &#123; int ans = 0; while(x) ans += C[x], x -= x &amp; -x; return ans; &#125;int main()&#123; RG int i; scanf("%d%u%u%u", &amp;n, &amp;SA, &amp;SB, &amp;SC); for(i = 1; i &lt;= n; ++i) a[i] = i; for(i = 1; i &lt;= n; ++i) b[i] = i; for(i = 1; i &lt;= n; ++i) c[i] = i; for(i = 1; i &lt;= n; ++i) swap(a[i], a[1 + Random() % n]); for(i = 1; i &lt;= n; ++i) swap(b[i], b[1 + Random() % n]); for(i = 1; i &lt;= n; ++i) swap(c[i], c[1 + Random() % n]); for(i = 1; i &lt;= n; ++i) q[a[i]] = (qry) &#123;a[i], b[i], c[i]&#125;; for(i = 1; i &lt;= n; ++i) ans += query(C1, q[i].b), add(C1, q[i].b); for(i = 1; i &lt;= n; ++i) q[b[i]] = (qry) &#123;a[i], b[i], c[i]&#125;; for(i = 1; i &lt;= n; ++i) ans += query(C2, q[i].c), add(C2, q[i].c); for(i = 1; i &lt;= n; ++i) q[c[i]] = (qry) &#123;a[i], b[i], c[i]&#125;; for(i = 1; i &lt;= n; ++i) ans += query(C3, q[i].a), add(C3, q[i].a); printf("%lld\n", (ans - 1ll * n * (n - 1) / 2) &gt;&gt; 1); return 0;&#125; T2太恶心，不写了 T3太毒瘤，不写了]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1042D】Petya and Array]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90CF1042D%E3%80%91Petya-and-Array%2F</url>
    <content type="text"><![CDATA[题面题解这道题目到底叫什么好呢？？ 史上最短CDQ分治题 记一个前缀和，然后CDQ分治即可。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define RG registerinline long long read()&#123; long long data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(2e5 + 10);int n;long long sum[maxn], t, ans;void Div(long long *beg, long long *end)&#123; if(end - beg &lt;= 1) return; long long *mid = beg + ((end - beg) &gt;&gt; 1); Div(beg, mid); Div(mid, end); for(long long *i = beg, *j = mid; i != mid; ++i, ans += j - mid) while(j != end &amp;&amp; (*j) &lt; t + (*i)) ++j; std::inplace_merge(beg, mid, end);&#125;int main()&#123; n = read(); t = read(); for(RG int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + read(); Div(sum, sum + n + 1); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2015】接水果]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90HNOI2015%E3%80%91%E6%8E%A5%E6%B0%B4%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[题面题解这道题要求关于第k大的东西，所以可以想到用主席树或整体二分 我们可以发现，这道题主要的难点就是路径之间的包含关系，那么我们分情况讨论： 1. LCA不是两个端点令这个盘子的两个端点为$a,b$ 如果被一个水果完全覆盖， 那么，这个水果的两端分别在$a,b$的子树中 设$pos[a]$是$a$的$dfs$序，$end_pos[a]$是子树中最大的$pos$，水果两端分别为$c, d$ 则 $$pos[a] \leq pos[c] \leq end_pos[a] \pos[b] \leq pos[d] \leq end_pos[b]$$ 2. LCA是其中一个端点令$a=LCA(a,b)$ 那么，一个点还是在$b$的子树内 另一个点在这条链的子树外 设$a,b$链上的$a$的儿子为$s$ 那么，水果的一个点一定不在$s$的子树内 即： $$pos[b] \leq pos[c] \leq end_pos[b] \pos[d] &lt; pos[s] \; || \; end_pos[s] &lt; pos[d]$$ 我们将盘子的$pos[a],pos[b],end_pos[a],end_pos[b]$看成两个点 组成了一个矩形 所以，一个盘子如果被水果所完全覆盖 那么，也就是水果组成的点被盘子组成的矩形所包含 所以整体二分+扫描线求解即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));#define for_edge(i, x) for(RG int i = head[x]; i; i = e[i].next)#define OPERATOR(Name, key, opt) inline bool operator opt (const Name &amp;a, const Name &amp;b) &#123; return a.key opt b.key; &#125;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data * w;&#125;const int maxn(50010);struct edge &#123; int next, to; &#125; e[maxn &lt;&lt; 1];int head[maxn], e_num, n, P, Q, fa[20][maxn], dep[maxn], pos[maxn], end_pos[maxn], cnt, q_cnt;inline void add_edge(int from, int to) &#123; e[++e_num] = (edge) &#123;head[from], to&#125;; head[from] = e_num; &#125;struct Matrix &#123; int x1, y1, x2, y2, k; &#125; t[maxn &lt;&lt; 2];struct Node &#123; int x, y, k, id; &#125; q[maxn], pl[maxn], pr[maxn];struct InNode &#123; int l, r, x, val; &#125; L[maxn];OPERATOR(Matrix, k, &lt;); OPERATOR(Node, x, &lt;); OPERATOR(InNode, x, &lt;);void dfs(int x)&#123; pos[x] = ++cnt; for(RG int i = 1; i &lt;= 15; i++) fa[i][x] = fa[i - 1][fa[i - 1][x]]; for_edge(i, x) &#123; int to = e[i].to; if(to == fa[0][x]) continue; fa[0][to] = x; dep[to] = dep[x] + 1; dfs(to); &#125; end_pos[x] = cnt;&#125;template&lt;int T&gt;inline int LCA(int a, int b)&#123; if(dep[a] &lt; dep[b]) std::swap(a, b); for(RG int i = 15; ~i; i--) if(dep[fa[i][a]] &gt; dep[b]) a = fa[i][a]; if(fa[0][a] == b) return T ? a : b; a = fa[0][a]; for(RG int i = 15; ~i; i--) if(fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b]; return T ? a : fa[0][a];&#125;int c[maxn], ans[maxn];inline void update(int x, int v) &#123; while(x &lt;= n) c[x] += v, x += x &amp; -x; &#125;inline int query(int x) &#123; int Ans = 0; while(x) Ans += c[x], x -= x &amp; -x; return Ans; &#125;void Div(int l, int r, int ql, int qr)&#123; if(ql &gt; qr) return; if(l == r) &#123; for(RG int i = ql; i &lt;= qr; i++) ans[q[i].id] = t[l].k; return; &#125; int mid = (l + r) &gt;&gt; 1, tl = 0, tr = 0, cntL = 0, p = 1; for(RG int i = l; i &lt;= mid; i++) L[++cntL] = (InNode) &#123;t[i].y1, t[i].y2, t[i].x1, 1&#125;, L[++cntL] = (InNode) &#123;t[i].y1, t[i].y2, t[i].x2 + 1, -1&#125;; std::sort(L + 1, L + cntL + 1); for(RG int i = ql; i &lt;= qr; i++) &#123; while(p &lt;= cntL &amp;&amp; L[p].x &lt;= q[i].x) update(L[p].l, L[p].val), update(L[p].r + 1, -L[p].val), ++p; int sum = query(q[i].y); if(q[i].k &lt;= sum) pl[++tl] = q[i]; else q[i].k -= sum, pr[++tr] = q[i]; &#125; for(RG int i = 1; i &lt; p; i++) update(L[i].l, -L[i].val), update(L[i].r + 1, L[i].val); for(RG int i = 1; i &lt;= tl; i++) q[ql + i - 1] = pl[i]; for(RG int i = 1; i &lt;= tr; i++) q[ql + tl + i - 1] = pr[i]; Div(l, mid, ql, ql + tl - 1); Div(mid + 1, r, ql + tl, qr);&#125;int main()&#123; n = read(); P = read(); Q = read(); for(RG int i = 1, a, b; i &lt; n; i++) a = read(), b = read(), add_edge(a, b), add_edge(b, a); dep[1] = 1; dfs(1); for(RG int i = 1, a, b, k; i &lt;= P; i++) &#123; a = read(); b = read(); k = read(); if(pos[a] &gt; pos[b]) std::swap(a, b); int lca = LCA&lt;0&gt;(a, b); if(a != lca) t[++q_cnt] = (Matrix) &#123;pos[a], pos[b], end_pos[a], end_pos[b], k&#125;; else &#123; int Lca = LCA&lt;1&gt;(a, b); if(pos[Lca] != 1) t[++q_cnt] = (Matrix) &#123;1, pos[b], pos[Lca] - 1, end_pos[b], k&#125;; if(end_pos[Lca] != n) t[++q_cnt] = (Matrix) &#123;pos[b], end_pos[Lca] + 1, end_pos[b], n, k&#125;; &#125; &#125; for(RG int i = 1, a, b, k; i &lt;= Q; i++) &#123; a = read(); b = read(); k = read(); if(pos[a] &gt; pos[b]) std::swap(a, b); q[i] = (Node) &#123;pos[a], pos[b], k, i&#125;; &#125; std::sort(t + 1, t + q_cnt + 1); std::sort(q + 1, q + Q + 1); clear(c, 0); Div(1, q_cnt, 1, Q); for(RG int i = 1; i &lt;= Q; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>整体二分</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-10-17考试]]></title>
    <url>%2F2018%2F10%2F20%2F2018-10-17%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[T1题面智者奥尔曼曾说过： 有缘的人即使相隔海角天涯， 也会在梦境中相遇。 IcePrince_1968 和 IcePrincess_1968 便是如此。 有一天 IcePrincess_1968 突发奇想： 为什么不用梦境操控仪器来增加她和 IcePrince_1968 的缘分呢？ IcePrincess_1968 的梦境可以用 n 个区间来表示，第 i 个区间[li,ri]表示她的第 i 个梦境会在 li 时刻开始， 在 ri 时刻结束（ 包含 li 和 ri 两个时刻） 。 因为IcePrincess_1968 经常做白日梦， 所以 n 可能很大。 两个人的梦境不是什么时候都能融合的。只有在一些关键的与另一个人相关的梦境转折点两个人的梦境相遇， 才能完成融合， 形成浪漫的梦境。 IcePrincess_1968 探测到IcePrince_1968 近期的 m 个与 IcePrincess_1968 相关的梦境转折点， 第 i 个转折点 ti 表示他的第 i 个梦境转折点会在 ti 时刻出现。 因为 IcePrince_1968 和 IcePrincess_1968 很有缘，IcePrince_1968 经常梦到 IcePrincess_1968， 所以 m 可能会很大。 当 IcePrincess_1968 的一个梦境包含了 IcePrince_1968 的一个梦境转折点时，两个人的这两段梦境就能得到融合。 但要注意 IcePrincess_1968 的每段梦境只能和 IcePrince_1968 的一个梦境转折点融合， 类似的， IcePrince_1968 的每个梦境转折点只能和 IcePrincess_1968的一段梦境融合， 否则会引发时空混乱。 IcePrincess_1968 很喜欢做和 IcePrince_1968 相关的梦。 所以她想算出她的这些梦境最多能和 IcePrince_1968 的梦境转折点融合出多少个浪漫的梦境。 IcePrincess_1968 擅长文学但不擅长计算机， 所以只能找你帮忙。 题解… 考虑贪心，将区间按右端点排序，找到离左端点最近的一个转折点，用$multiset$维护即可 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#define RG registerinline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(200010);struct node &#123; int l, r; &#125; d[maxn];inline bool cmp(const node &amp;lhs, const node &amp;rhs) &#123; return lhs.r &lt; rhs.r || (lhs.r == rhs.r &amp;&amp; lhs.l &lt; rhs.l); &#125;int t[maxn], n, m;std::multiset&lt;int&gt; s;int main()&#123; n = read(); m = read(); for(RG int i = 1; i &lt;= n; i++) d[i] = (node) &#123;read(), read()&#125;; for(RG int i = 1; i &lt;= m; i++) s.insert(t[i] = read()); std::sort(d + 1, d + n + 1, cmp); int ans = 0; std::multiset&lt;int&gt;::iterator it; for(RG int i = 1; i &lt;= m; i++) &#123; it = s.lower_bound(d[i].l); if(it == s.end() || *it &gt; d[i].r) continue; ++ans; s.erase(it); &#125; printf("%d\n", ans); return 0;&#125; T2题面给定一棵有$n$个节点的树，求它树高的期望 题解妙啊 预处理$dp[i][j]$表示$i$个点的森林,有$j$个点在第一棵树的概率,转移考虑第$i$个点是否在第一棵子树中,我们有状态转移方程$$dp[i][j] = dp[i − 1][j − 1] ∗ (j − 1) ∗ inv[i] + dp[i − 1][j] ∗ (i − j) ∗ inv[i]$$考虑修改算法三中状态的含义,令$f[i][j]$表示有$i$个点的树,深度不超过$j$的概率,$g[i][j]$表示有$i$个点的森林,深度不超过$j$的概率,$f[i][j]$直接从$g[i-1][j-1]$转移来;$g[i][j]$考虑枚举第一棵树的大小$k$,从一棵树和一个森林转移来,同时还要乘上第一棵子树大小为$k$的概率,我们有状态转移方程:$$g[i][j] = \sum_{k = 1} ^ i f[k][j] g[i - k][j] dp[i][k]$$具体的细节可以看标程。最后只要用$f[n][j]-f[n][j-1]$就可以得到深度为$j$的树的概率时间复杂度: $O(n^3)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;cstring&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(210);int n, p, inv[maxn];inline int Inv(int x)&#123; static int ans, y; ans = 1; y = p - 2; x %= p; while(y) &#123; if(y &amp; 1) ans = 1ll * ans * x % p; x = 1ll * x * x % p; y &gt;&gt;= 1; &#125; return ans;&#125;int dp[maxn][maxn], f[maxn][maxn], g[maxn][maxn], ans[maxn];inline int F(int i, int j);inline int G(int i, int j)&#123; if(j &lt; 0) return 0; if(i == 0) return 1; if(~g[i][j]) return g[i][j]; g[i][j] = 0; for(RG int k = 1; k &lt;= i; k++) g[i][j] = (g[i][j] + (1ll * (1ll * F(k, j) * G(i - k, j) % p) * dp[i][k]) % p) % p; return g[i][j];&#125;inline int F(int i, int j)&#123; if(~f[i][j]) return f[i][j]; return f[i][j] = G(i - 1, j - 1);&#125;int main()&#123; n = read(); p = read(); inv[1] = 1; for(RG int i = 2; i &lt;= n; i++) inv[i] = Inv(i); if(n == 0) return puts("0") &amp; 0; dp[1][1] = 1; for(RG int i = 2; i &lt;= n; i++) for(RG int j = 1; j &lt;= i; j++) dp[i][j] = ((1ll * (1ll * dp[i - 1][j - 1] * (j - 1) % p) * inv[i] % p) + (1ll * (1ll * dp[i - 1][j] * (i - j) % p) * inv[i] % p)) % p; clear(f, -1); clear(g, -1); for(RG int i = 2; i &lt;= n; i++) ans[i] = F(n, i); ans[1] = 0; int ANS = 0; for(RG int i = 2; i &lt;= n; i++) ANS = (ANS + (1ll * ((ans[i] - ans[i - 1]) % p) * i) % p) % p; printf("%d\n", (ANS - 1 + p) % p); return 0;&#125; T3题面IcePrincess_1968 和 IcePrince_1968 长大了， 他们开始协助国王 IceKing_1968 管理国内事物。 IcePrincess_1968 和 IcePrince_1968 住在一个宁静悠远的王国： IceKingdom —— 飘雪圣域。 飘雪圣域有 n 个城镇， 编号 1,2,3…n。 有些城镇之间有道路， 且满足任意两点之间有且仅有一条路径。 飘雪圣域风景优美， 但气候并不是太好。 根据 IcePrince_1968 的气候探测仪，将来会发生 q 场暴风雪。 每场暴风雪可以用两个整数 li,ri 刻画， 表示这场暴风雪之后， 只有编号属于[li,ri]的城市没有受到暴风雪的影响。 在暴风雪的影响下迅速确定王国的农业生产方案是非常重要的事情。IceKing_1968 认为， 一个农业生产地域应该是一个极大连通块， 满足每个节点都没有被暴风雪影响。 这里极大连通块的定义是： 不存在一个不属于该点集的未被暴风雪影响的点与该连通块连通。 IcePrincess_1968 要负责算出每次暴风雪后， 王国能拥有多少个农业生产地域。 注意这里每次暴风雪是独立的， 即每次暴风雪过后， 直到每个城镇重新焕发生机， 下一次暴风雪才会到来。 正如上文所述， IcePrincess_1968 擅长文学但不擅长计算机， 于是请你帮忙。 题解其实，对于一个询问$[l_i,r_i]$，我们只要知道有多少条边的两个端点都没有被暴风雪影响，就可以$O(1)$算联通块的个数。 记$num$为没有被暴风雪影响的边的个数，答案就是$r_i-l_i+1-num$。 我们可以离线做，将原树中所有的边按照编号较大的点从大到小排序,再将询问按右端点从大到小排序。 用一个树状数组来维护所有区间的左端点,刚开始将所有区间的左端点加入$BIT$,随着询问区间右端点的左移,必然会有一些新的右端点在区间右端点之左的边变得不合法,将这些边从$BIT$里删除,即$BIT$实时维护右端点在当前查询区间右端点左边的所有树边的左端点。 因为左端点一定在右端点左边,所以只要一条树边的左端点在查询区间的左端点右边,这条边就一定合法,所以将每个询问在$BIT$里面查询一下即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;vector&gt;#define RG registerinline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(200010);struct edge &#123; int next, to; &#125; e[maxn &lt;&lt; 1];int head[maxn], e_num, n, q, fa[maxn];inline void add_edge(int from, int to) &#123; e[++e_num] = (edge) &#123;head[from], to&#125;; head[from] = e_num; &#125;void dfs(int x)&#123; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(to == fa[x]) continue; fa[to] = x; dfs(to); &#125;&#125;struct qry &#123; int l, r, opt, id; &#125; p[maxn &lt;&lt; 1];std::vector&lt;int&gt; Q[maxn];int ans[maxn], c[maxn], cnt;inline void add(int x, int v) &#123; while(x &lt;= n) c[x] += v, x += x &amp; -x; &#125;inline int query(int x) &#123; int ans = 0; while(x) ans += c[x], x -= x &amp; -x; return ans; &#125;inline int query(int l, int r) &#123; return query(r) - query(l - 1); &#125;int main()&#123; n = read(); q = read(); for(RG int i = 1, a, b; i &lt; n; i++) a = read(), b = read(), add_edge(a, b), add_edge(b, a); dfs(1); for(RG int i = 1, l, r; i &lt;= q; i++) &#123; l = read(); r = read(); ans[i] = r - l + 1; if(l &gt; 2) p[++cnt] = (qry) &#123;l, r, 1, i&#125;, Q[l - 1].push_back(cnt); p[++cnt] = (qry) &#123;l, r, -1, i&#125;; Q[r].push_back(cnt); &#125; std::vector&lt;int&gt;::iterator it; for(RG int i = 1; i &lt;= n; i++) &#123; if(fa[i]) add(fa[i], 1); for(it = Q[i].begin(); it != Q[i].end(); ++it) ans[p[*it].id] += p[*it].opt * (query(p[*it].l, p[*it].r)); &#125; for(RG int i = 1; i &lt;= q; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CTSC2008】网络管理]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90CTSC2008%E3%80%91%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[题面题解带修改的主席树？？？我可没有那么勤快去写个树套树 只要它不强制在线，我就可以用整体二分做 思路大致与【ZJOI2013】K大数查询相似 只不过放在树上做，还带修改 同样处理出询问，并且一个修改操作要拆分成两个 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(80010);struct edge &#123; int next, to; &#125; e[maxn &lt;&lt; 1];int head[maxn], e_num, n, q;inline void add_edge(int from, int to) &#123; e[++e_num] = (edge) &#123;head[from], to&#125;; head[from] = e_num; &#125;int pos[maxn], fa[maxn], size[maxn], heavy[maxn], belong[maxn], dep[maxn], cnt;void dfs(int x)&#123; size[x] = 1; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(to == fa[x]) continue; fa[to] = x; dep[to] = dep[x] + 1; dfs(to); size[x] += size[to]; if(size[heavy[x]] &lt; size[to]) heavy[x] = to; &#125;&#125;void dfs(int x, int chain)&#123; pos[x] = ++cnt; belong[x] = chain; if(!heavy[x]) return; dfs(heavy[x], chain); for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(to == fa[x] || to == heavy[x]) continue; dfs(to, to); &#125;&#125;int sum, ans[maxn], c[maxn], T[maxn];struct qry &#123; int k, a, b, id, opt; &#125; p[maxn &lt;&lt; 1], pl[maxn &lt;&lt; 1], pr[maxn &lt;&lt; 1];inline void add(int x, int v) &#123; while(x &lt;= n) c[x] += v, x += x &amp; -x; &#125;inline int query(int x) &#123; int ans = 0; while(x) ans += c[x], x -= x &amp; -x; return ans; &#125;inline int LCA(int a, int b)&#123; while(belong[a] ^ belong[b]) &#123; if(pos[belong[a]] &lt; pos[belong[b]]) std::swap(a, b); a = fa[belong[a]]; &#125; return pos[a] &lt; pos[b] ? a : b;&#125;inline int Query(int a, int b)&#123; int ans = 0; while(belong[a] ^ belong[b]) &#123; if(pos[belong[a]] &lt; pos[belong[b]]) std::swap(a, b); ans += query(pos[a]) - query(pos[belong[a]] - 1); a = fa[belong[a]]; &#125; if(pos[a] &lt; pos[b]) std::swap(a, b); return ans + query(pos[a]) - query(pos[b] - 1);&#125;void Div(int l, int r, int ql, int qr)&#123; if(ql &gt; qr) return; if(l == r) &#123; for(RG int i = ql; i &lt;= qr; i++) if((!p[i].opt) &amp;&amp; (~ans[p[i].id])) ans[p[i].id] = l; return; &#125; int mid = (l + r) &gt;&gt; 1, tl = 0, tr = 0; for(RG int i = ql; i &lt;= qr; i++) &#123; if(p[i].k == 0) if(p[i].b &lt;= mid) pl[++tl] = p[i]; else pr[++tr] = p[i], add(pos[p[i].a], p[i].id); else &#123; int sum = Query(p[i].a, p[i].b); if(sum &gt;= p[i].k) pr[++tr] = p[i]; else p[i].k -= sum, pl[++tl] = p[i]; &#125; &#125; for(RG int i = ql; i &lt;= qr; i++) if(p[i].opt &amp;&amp; p[i].b &gt; mid) add(pos[p[i].a], -p[i].id); for(RG int i = 1; i &lt;= tl; i++) p[ql + i - 1] = pl[i]; for(RG int i = 1; i &lt;= tr; i++) p[ql + tl + i - 1] = pr[i]; Div(l, mid, ql, ql + tl - 1); Div(mid + 1, r, ql + tl, qr);&#125;int main()&#123;#ifndef ONLINE_JUDGE file(cpp);#endif n = read(); q = read(); int tot = 0; for(RG int i = 1; i &lt;= n; i++) p[++tot] = (qry) &#123;0, i, T[i] = read(), 1, 1&#125;; for(RG int i = 1, a, b; i &lt; n; i++) a = read(), b = read(), add_edge(a, b), add_edge(b, a); dfs(1); dfs(1, 1); for(RG int i = 1, k, a, b; i &lt;= q; i++) &#123; k = read(); a = read(); b = read(); if(k) &#123; p[++tot] = (qry) &#123;k, a, b, ++sum, 0&#125;; int dis = dep[a] + dep[b] - (dep[LCA(a, b)] &lt;&lt; 1) + 1; if(p[tot].k &gt; dis) ans[p[tot].id] = -1; &#125; else p[++tot] = (qry) &#123;0, a, T[a], -1, 1&#125;, p[++tot] = (qry) &#123;0, a, T[a] = b, 1, 1&#125;; &#125; Div(1, 100000000, 1, tot); for(RG int i = 1; i &lt;= sum; i++) (~ans[i]) ? printf("%d\n", ans[i]) : puts("invalid request!"); return 0;&#125;]]></content>
      <tags>
        <tag>整体二分</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2013】K大数查询]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90ZJOI2013%E3%80%91K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[题面题解整体二分 区间查询可以二分，把所有的询问放在一起，用线段树区间查询即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define RG registerusing namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(50010);struct node&#123; bool clr; int lazy; long long sum; inline void clear() &#123; clr=lazy=sum=0; &#125;&#125;tree[maxn &lt;&lt; 2];int n, m, ans[maxn];#define son(i) ((root&lt;&lt;1)|i)inline void pushdown(int root, int l, int r)&#123; if(tree[root].clr) &#123; tree[son(0)].clear(); tree[son(1)].clear(); tree[son(0)].clr=tree[son(1)].clr=1; tree[root].clr=0; &#125; int mid(l+r&gt;&gt;1); tree[son(0)].sum+=tree[root].lazy*(mid-l+1); tree[son(1)].sum+=tree[root].lazy*(r-mid); tree[son(0)].lazy+=tree[root].lazy; tree[son(1)].lazy+=tree[root].lazy; tree[root].lazy=0;&#125;void update(int ql, int qr, int root=1, int l=1, int r=n)&#123; if(r&lt;ql || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; tree[root].sum+=r-l+1; tree[root].lazy++; return; &#125; pushdown(root, l, r); int mid(l+r&gt;&gt;1); update(ql, qr, son(0), l, mid); update(ql, qr, son(1), mid+1, r); tree[root].sum=tree[son(0)].sum+tree[son(1)].sum;&#125;long long query(int ql, int qr, int root=1, int l=1, int r=n)&#123; if(r&lt;ql || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return tree[root].sum; pushdown(root, l, r); int mid(l+r&gt;&gt;1); return query(ql, qr, son(0), l, mid)+query(ql, qr, son(1), mid+1, r);&#125;struct question &#123; int opt, l, r, c, id; &#125; p[maxn], p1[maxn], p2[maxn];void divde(int ql, int qr, int l, int r)&#123; if(ql&gt;qr) return; if(l==r) &#123; for(RG int i=ql;i&lt;=qr;i++) ans[p[i].id]=l; return; &#125; int mid=(l+r)&gt;&gt;1, t1=0, t2=0; for(RG int i=ql;i&lt;=qr;i++) &#123; if(p[i].opt^1) &#123; long long q=query(p[i].l, p[i].r); if(q&gt;=p[i].c) p2[++t2]=p[i]; else p[i].c-=q, p1[++t1]=p[i]; &#125; else &#123; if(p[i].c&lt;=mid) p1[++t1]=p[i]; else &#123; p2[++t2]=p[i]; update(p[i].l, p[i].r); &#125; &#125; &#125; for(RG int i=1;i&lt;=t1;i++) p[ql+i-1]=p1[i]; for(RG int i=1;i&lt;=t2;i++) p[ql+t1+i-1]=p2[i]; tree[1].clear(); tree[1].clr=1; divde(ql, ql+t1-1, l, mid); divde(ql+t1, qr, mid+1, r);&#125;int main()&#123; n=read(); m=read(); int tot=0; for(RG int i=1;i&lt;=m;i++) &#123; p[i]=(question)&#123;read(), read(), read(), read(), 0&#125;; if(p[i].opt^1) p[i].id=++tot; &#125; divde(1, m, -n, n); for(RG int i=1;i&lt;=tot;i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>整体二分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POI2011】MET-Meteors]]></title>
    <url>%2F2018%2F10%2F20%2FMET-Meteors%2F</url>
    <content type="text"><![CDATA[题面题解首先我们尝试暴力，那么就对每个点二分一下即可。 我们发现单独二分复杂度太高，而且有些地方很浪费，如求前缀和等。 那么我们就想，能否将它们合并在一起二分呢？ 于是就有了整体二分 整体二分即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(3e5 + 10);struct node &#123; int l, r; long long a; &#125; r[maxn];struct qry &#123; int id; long long p; &#125; p[maxn], pl[maxn], pr[maxn];long long c[maxn]; std::vector&lt;int&gt; a[maxn];int n, m, ans[maxn], K;inline void add(int x, int v) &#123; while(x &lt;= m) c[x] += v, x += x &amp; -x; &#125;inline long long query(int x) &#123; long long ans = 0; while(x) ans += c[x], x -= x &amp; -x; return ans; &#125;inline void fall(int x, int o)&#123; if(r[x].l &gt; r[x].r) add(1, o * r[x].a); add(r[x].l, o * r[x].a); add(r[x].r + 1, -o * r[x].a);&#125;inline bool check(int x, long long &amp;sum)&#123; sum = 0; static std::vector&lt;int&gt;::iterator it; for(it = a[p[x].id].begin(); it != a[p[x].id].end(); ++it) &#123; sum += query(*it); if(sum &gt;= p[x].p) return true; &#125; return false;&#125;void Div(int l, int r, int ql, int qr)&#123; if(ql &gt; qr) return; if(l == r) &#123; for(RG int i = ql; i &lt;= qr; i++) ans[p[i].id] = l; return; &#125; int mid = (l + r) &gt;&gt; 1, tl = 0, tr = 0; long long sum; for(RG int i = l; i &lt;= mid; i++) fall(i, 1); for(RG int i = ql; i &lt;= qr; i++) if(check(i, sum)) pl[++tl] = p[i]; else p[i].p -= sum, pr[++tr] = p[i]; for(RG int i = l; i &lt;= mid; i++) fall(i, -1); for(RG int i = 1; i &lt;= tl; i++) p[i + ql - 1] = pl[i]; for(RG int i = 1; i &lt;= tr; i++) p[i + ql + tl - 1] = pr[i]; Div(l, mid, ql, ql + tl - 1); Div(mid + 1, r, ql + tl, qr);&#125;int main()&#123;#ifndef ONLINE_JUDGE file(cpp);#endif n = read(); m = read(); for(RG int i = 1; i &lt;= m; i++) a[read()].push_back(i); for(RG int i = 1; i &lt;= n; i++) p[i] = (qry) &#123;i, read()&#125;; K = read(); for(RG int i = 1; i &lt;= K; i++) r[i] = (node) &#123;read(), read(), read()&#125;; r[++K] = (node) &#123;1, m, 1000000000&#125;; Div(1, K, 1, n); for(RG int i = 1; i &lt;= n; i++) ans[i] == K ? puts("NIE") : printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Moiezen]]></title>
    <url>%2F2018%2F10%2F20%2FMoiezen%2F</url>
    <content type="text"><![CDATA[题面$MYC$ 带着他的行李去考清华集训了。对 $MYC$ 来说,进候选队不在话下。。。$MYC$ 有 $n$ 件行李,编号为 $1,2,…,n$。行李的质量是模 $P$ 意义下的($P$ 不一定是质数)。$MYC$有 $k$ 个背包,要装下这些行李,为了方便 $MYC$ 在背包中找行李,每个背包中的行李编号是连续的,允许有背包为空。$MYC$ 想让最重的背包尽量轻。由于 $MYC$ 毕竟是要进候选队的人,他有特技可以用。他会选择一个 $x(0&lt;=x&lt;P)$,给所有行李的质量$+x$并$\%P$,然后才装到背包里去。你要帮助 $MYC$ 先选择一个 $x$,再选择一种行李分配方案,使得最重的背包尽量轻。$MYC$ 相信,你一定能帮他装好行李,给拼搏于候选队的逐梦之路上的 $MYC$,提供一个有力的援助。 题解随机化 考虑暴力，枚举$x$，二分背包最小重量即可 时间复杂度$O(Pnlogn)$，跑不过 考虑剪枝：如果在二分之前$check(ans)$非法，那么当前这个方案一定不可行。 于是$random_shuffle$一下保证时间复杂度：$O($跑得过$)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;climits&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#define RG registerusing namespace std;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(10010);int n, P, k, ans, a[maxn], _max, d[maxn];inline bool check(int mid, int x)&#123; for(RG int i = 1, w = 0, t, cnt = 1; i &lt;= n; i++) &#123; t = (a[i] + x) % P; if(mid &lt; t) return false; if(w + t &gt; mid) ++cnt, w = 0; if(cnt &gt; k) return false; w += t; &#125; return true;&#125;inline void Solve(int x)&#123; _max = 0; for(RG int i = 1; i &lt;= n; i++) _max = max(_max, (a[i] + x) % P); int l = _max, r = 1e8 + 1, res = r; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid, x)) res = mid, r = mid - 1; else l = mid + 1; &#125; ans = min(ans, res);&#125;int main()&#123; srand(time(NULL)); n = read(); P = read(); k = read(); for(RG int i = 1; i &lt;= n; i++) a[i] = read(); for(RG int i = 1; i &lt;= P; i++) d[i] = i - 1; ans = 1e8; random_shuffle(d + 1, d + P + 1); for(RG int i = 1; i &lt;= P; i++) &#123; if(!check(ans, d[i])) continue; Solve(d[i]); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>贪心</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPOJ11469 SUBSET]]></title>
    <url>%2F2018%2F10%2F20%2FSPOJ-SUBSET%2F</url>
    <content type="text"><![CDATA[题面Farmer John’s owns N cows (2 &lt;= N &lt;= 20), where cow i produces M(i) units of milk each day (1 &lt;= M(i) &lt;= 100,000,000). FJ wants to streamline the process of milking his cows every day, so he installs a brand new milking machine in his barn. Unfortunately, the machine turns out to be far too sensitive: it only works properly if the cows on the left side of the barn have the exact same total milk output as the cows on the right side of the barn! Let us call a subset of cows “balanced” if it can be partitioned into two groups having equal milk output. Since only a balanced subset of cows can make the milking machine work, FJ wonders how many subsets of his N cows are balanced. Please help him compute this quantity. 有多少个非空子集,能划分成和相等的两份。 题解我在考场上打的是暴力$3^n$，我不会告诉你我CE了 我们可以$3^{n/2}$枚举两边的子集，然后$meeting\;in\;the\;middle$即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;vector&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(21);int n, a[maxn], ok[1 &lt;&lt; maxn], cnt, ans;typedef std::vector&lt;int&gt;::iterator iter;std::map&lt;int, int&gt; map;std::vector&lt;int&gt; set[1 &lt;&lt; maxn];void dfs(int x, int s, int d)&#123; if(x &gt; (n &gt;&gt; 1) - 1) &#123; if(map.find(d) == map.end()) map[d] = ++cnt; int t = map[d]; set[t].push_back(s); return; &#125; dfs(x + 1, s, d); dfs(x + 1, s | (1 &lt;&lt; x), d + a[x]); dfs(x + 1, s | (1 &lt;&lt; x), d - a[x]);&#125;void Dfs(int x, int s, int d)&#123; if(x &gt; n - 1) &#123; if(map.find(d) == map.end()) return; int t = map[d]; for(RG iter it = set[t].begin(); it != set[t].end(); ++it) ok[(*it) | s] = 1; return; &#125; Dfs(x + 1, s, d); Dfs(x + 1, s | (1 &lt;&lt; x), d + a[x]); Dfs(x + 1, s | (1 &lt;&lt; x), d - a[x]);&#125;int main()&#123; n = read(); for(RG int i = 0; i &lt; n; i++) a[i] = read(); dfs(0, 0, 0); Dfs((n &gt;&gt; 1), 0, 0); for(RG int i = (1 &lt;&lt; n) - 1; i; i--) ans += ok[i]; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>折半枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP2012】疫情控制]]></title>
    <url>%2F2018%2F10%2F14%2F%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题面题解最少要多少个小时 -&gt; 二分答案首先我们贪心的想：要尽量将军队往上提，然后让一些军队在根节点边转移我们可以优化将军队往上提的过程 -&gt; 倍增，然后就很好check了。注意：在写的时候要思路清晰，不然一下子就晕了。代码里每一步都标得很清楚了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using std::sort;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data * w;&#125;const int maxn(5e5 + 10);struct edge &#123; int next, to, dis; &#125; e[maxn &lt;&lt; 1];struct node &#123; long long val; int id; &#125; a[maxn], b[maxn]; // a表示军队，b表示没封住的子树// a[].val -&gt; 剩余时间，b[].val -&gt; 离根的距离int head[maxn], e_num, n, m, pos[maxn], cnta, cntb;inline bool cmp(const node &amp;lhs, const node &amp;rhs) &#123; return lhs.val &lt; rhs.val; &#125;inline void add_edge(int from, int to, int dis)&#123; e[++e_num] = (edge) &#123;head[from], to, dis&#125;; head[from] = e_num; e[++e_num] = (edge) &#123;head[to], from, dis&#125;; head[to] = e_num;&#125;int dep[maxn], f[maxn][22], dis[maxn][22], vis[maxn];void dfs(int x)&#123; for(RG int i = 1; i &lt;= 20 &amp;&amp; f[f[x][i - 1]][i - 1]; i++) f[x][i] = f[f[x][i - 1]][i - 1], dis[x][i] = dis[f[x][i - 1]][i - 1] + dis[x][i - 1]; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(to == f[x][0]) continue; dep[to] = dep[x] + 1; f[to][0] = x; dis[to][0] = e[i].dis; dfs(to); &#125;&#125;void pushdown(int x)&#123; bool a = 1, b = 0; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(to == f[x][0]) continue; pushdown(to); a &amp;= vis[to]; b = 1; &#125; if(x != 1 &amp;&amp; a &amp;&amp; b) vis[x] = 1;&#125;inline bool check(int mid)&#123; cnta = cntb = 0; clear(vis, 0); // let army jump for(RG int i = 1; i &lt;= m; i++) &#123; int x = pos[i], t = 0; for(RG int j = 20; ~j; j--) if(f[x][j] &amp;&amp; t + dis[x][j] &lt;= mid) t += dis[x][j], x = f[x][j]; if(x != 1) vis[x] = 1; else &#123; x = pos[i]; a[++cnta].val = mid - t; for(RG int j = 20; ~j; j--) if(f[x][j] &gt; 1) x = f[x][j]; a[cnta].id = x; &#125; &#125; // find subtrees pushdown(1); for(RG int i = head[1]; i; i = e[i].next) &#123; int to = e[i].to; if(vis[to]) continue; b[++cntb] = (node) &#123;e[i].dis, to&#125;; &#125; // sort them sort(a + 1, a + cnta + 1, cmp); sort(b + 1, b + cntb + 1, cmp); // solve them RG int p = 1; for(RG int i = 1; i &lt;= cnta; i++) &#123; if(!vis[a[i].id]) vis[a[i].id] = 1; else if(a[i].val &gt;= b[p].val) vis[b[p].id] = 1; while(vis[b[p].id] &amp;&amp; p &lt;= cntb) ++p; &#125; return cntb &lt; p;&#125;int main()&#123;#ifndef ONLINE_JUDGE file(cpp);#endif n = read(); int sum = 0; for(RG int i = 1, a, b, c; i &lt; n; i++) a = read(), b = read(), sum += (c = read()), add_edge(a, b, c); dep[1] = 1; dfs(1); m = read(); for(RG int i = 1; i &lt;= m; i++) pos[i] = read(); int l = 0, r = sum, ans; sum = 0; for(RG int i = 1; i &lt;= n; i++) sum += (dep[i] == 2); if(m &lt; sum) return puts("-1") &amp; 0; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid, r = mid - 1; else l = mid + 1; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>贪心</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[课件组合数学基础常用公式$\binom{n}{m} = \frac{n!}{m!(n-m)!}$ $\binom{n}{m} = \binom{n}{n-m}$ $\binom{n}{m} = \binom{n - 1}{m} + \binom{n - 1}{m - 1}$ $\binom{n}{m + 1} = \binom{n}{m} × \frac{n - m}{m + 1}$ 二项式定理$(a + b)^n = \sum_{i=0}^n\binom{n}{i}×a^i×b^{n - i}$ 可重组合$\binom{n + m - 1}{m}$ 第$i$种颜色的球有$a_i$个,求排列的方案数$\frac{(\sum a_i)!}{\prod a_i!}$ 从$(0,0)$走到$(n,m)$,不碰到直线$y=x+b​$的方案数$\binom{n + m}{n} - \binom{n + m}{n - b}$ 斯特林数 第一类斯特林数:$n$个人坐$m$张圆桌的方案数 $[m^n] = [{m-1}^{n-1}] + (n - 1)×[_m^{n-1}]$ 第二类斯特林数:$n$个球分成$m$个集合的方案数 ${^n_m} = {_{m-1}^{n-1}} + m×{^{n-1}_m}$ 容斥原理 +-+-+-+-+-+-+-+-…… 应用 zsy和yyb出现至少一人的概率(或方案数等)=zsy出现的概率+yyb出现的概率-两人同时出现的概率。 更常见的应用: zsy和yyb都不出现的概率=1-至少出现一人的概率,然后再容斥算后面那个东西。 更高级的应用: n个zsy全部咕咕的概率=1-至少咕一个的概率+至少咕两个的概率-……=1-至少咕奇数 个的概率+至少咕偶数个的概率。 错排问题给定$n$,问有多少个$1$~$n$的排列$p$满足不存在$i$满足$p_i=i$ Ans = n! -（至少有一组pi=i的方案数）+（至少有两组pi=i的方案数）- ……想要好看点就是这样：$$Ans = \sum_{i=0}^n(-1)^i×\binom{n}{i}×(n-i)!$$即钦定$i$个位置满足$p_i=i$，剩下的随便放。 走路问题从$(1,1)$走到$(n,m)$,其中有$k$个点$(x,y)$是不能走的,问有多少种方案。 设$f[i]$表示走到第$i$个特殊点（包括$(0,0)$,$(n,m)$以及$k$个障碍点）的方案数，则：$$f[i] = \sum j到i的方案数 × (-f[j])$$因为这个转移默认了$j$是障碍点（所以要变号），因此需要设$f[1]$（即$(0,0)$对应方案数）$=-1$。 初等数论扩展欧几里得用来求形如$ax+by=gcd(a,b)$的方程的整数解。据说用这种方法求出的解满足$|x|+|y|$最小。 1234inline void exgcd(long long a, long long b, long long &amp;gcd, long long &amp;x, long long &amp;y)&#123; !b ? gcd = a, x = 1, y = 0 : (exgcd(b, a % b, gcd, y, x), y -= x * (a / b));&#125; 欧拉定理$a^{φ(n)}\equiv1(mod\;n)$ 其中$φ(n)$为欧拉函数,即小于等于$n$,且与$n$互质的数的个数, $a,n$互质 $φ(n)=n×\prod(1-\frac{1}{a_i})$ 其中$a_i$是$n$的质因子。可以发现,对于质数$n$, $φ(n)=n-1$。 降幂对于指数很大的情况,可以根据欧拉定理降幂。 如果$n,a$互质:$a^b\equiv a^{b\%φ(n)}(mod\;n)$ 否则，根据扩展欧拉定理 当$b &lt; φ(n)$时 $a^b\equiv a^b(mod\;n)$ 当$b &gt;= φ(n)$时 $a^b\equiv a^{b\%φ(n)+φ(n)}(mod\;n)$ 逆元对于$B\equiv\frac{1}{A}(mod\;p)$称$B$为$A$在模$p$意义下的乘法逆元。 求乘法逆元有以下几种方法: 根据欧拉定理,快速幂求出:$B=A^{p-2}\%p$ 解方程$px+Ay=1$,则$Ay=1-px,y\equiv\frac{1}{A}(mod\;p)$ 递推求逆元: $inv[i] = p-([\frac{p}{i}]×inv[p\;mod\;i])\;mod\;p$ 筛法求质数复杂度$O(n)$的筛法: 123456789for(RG int i = 2; i &lt;= n; i++)&#123; if(!not_prime[i]) prime[++cnt] = i; for(RG int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123; not_prime[i * prime[j]] = 1; if(!(i % prime[j])) break; &#125;&#125; BSGS北上广深算法 用来求形如$a^x\equiv b(mod\;p)$的方程的解。 所以这东西怎么做呢？ 取$k=\lceil\sqrt{p}\rceil$，令$x=ky+z$，则$$a^{ky} \times a^z \equiv b (mod\;p),\;a^{ky} \equiv \frac{b}{a^z} (mod\;p)$$预处理出所有的$\frac{b}{a^z}$并哈希存储，枚举$y$后判断是否有满足条件的即可。 数列几个公式 平方和公式$\sum_{i=1}^ni^2=\frac{n(n+1)(2n+1)}{6}$ 立方和公式$\sum_{i=1}^ni^3=(\frac{n(n+1)}{2})^2$ 等比数列求和公式$S_n=\frac{a_1(1-p^n)}{1-p}$ 矩阵与方程矩阵乘法 矩阵乘法满足结合律,所以可以用类似数的快速幂的方式实现矩阵快速幂。 矩阵快速幂有什么用呢?我们考虑一个$1×n$的矩阵$a$和一个$n×n$的矩阵$b$相乘。 可以发现,对于得出的$1×n$的矩阵的第$i$个数$c_i$,满足:$$c_i=\sum b_{j,i}×a_j$$ 所以,我们可以用矩阵乘法来表示线性递推 高斯消元其实这里介绍的是高斯-约旦消元法。相对于传统的高斯消元,这种方法的精度更好, 代码更简单。(据说常数比较大,不过实测还是跑得蛮快的。。。) 大致思路如下对于每一步: 选择一个尚未被选过的未知数作为主元,选择一个包含这个主元的方程 将这个方程主元的系数化为1 通过加减消元,消掉其它方程中的这个未知数。 如果用一个$n×(n+1)$的矩阵表示方程组,消到最后,方程组会变成这样:$$\left[\begin{matrix}1 &amp; 0 &amp; … &amp; 0 &amp; 0 &amp; c_1 \0 &amp; 1 &amp; … &amp; 0 &amp; 0 &amp; c_2 \… &amp; … &amp; … &amp; … &amp; … &amp; … \0 &amp; 0 &amp; … &amp; 1 &amp; 0 &amp; c_{n-1} \0 &amp; 0 &amp; … &amp; 0 &amp; 1 &amp; c_n\end{matrix}\right]$$ 同余类最短路当数论与图论相结合,又会发生什么有意思的事呢? 不知道 概率与期望期望的线性性期望的线性性最大的好处就是,它不要求那被分别计算的若干种期望是不相关的。 所以,只要是和乘法没什么关系的期望题,我们都应该首先考虑期望的线性性。 例题组合数学基础洛谷P2822 组合数问题可以通过组合数的递推公式快速算出$i,j&lt;=2000$的组合数，从而算出其中$\%k=0$的有多少。可以通过二维前缀和将询问优化至$O(1)$。 需要注意的是，组合数$C(n,m)$随着n的增大是呈指数级增大的，所以需要边计算，边取模，以免爆精度。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define RG registerusing namespace std;inline int read()&#123; int data=0,w=1; char ch=0; while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1,ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=data*10+ch-'0',ch=getchar(); return data*w;&#125;int c[2010][2010], b[2010][2010];int n,m,t,k;int main()&#123; t=read(); k=read(); for(RG int i=0;i&lt;=2009;i++) &#123; c[i][0]=1; b[i][0]=bool(c[i][0])^1; for(RG int j=1;j&lt;=i;j++) &#123; c[i][j]=(c[i-1][j]+c[i-1][j-1])%k; b[i][j]=bool(c[i][j])^1; &#125; &#125; for(RG int i=0;i&lt;=2009;i++) for(RG int j=1;j&lt;=2009;j++) b[i][j]+=b[i][j-1]; for(RG int i=1;i&lt;=2009;i++) for(RG int j=0;j&lt;=2009;j++) b[i][j]+=b[i-1][j]; while(t--) &#123; n=read(); m=read(); printf("%d\n",b[n][m]); &#125; return 0;&#125; 洛谷P4609 [FJOI2016]建筑师高度为n的zsy无论如何都能从左右两侧看到。剩下的部分，从左边看到的是前缀max，从右侧看到的是后缀max。大概像这样： 对于被框住的$A+B-1$个部分，只有第一个能作为前、后缀$max$被看到。可以认为是把数分成$A+B-1$个圆排列，其中有一个仅包含$n$。剩下的$A+B-2$个，先决定放在$n$的左边还是右边。然后，将每个圆排列的将最大值钦定为所在方向(左或右)上的第一个，并以此为关键字将圆排列排序后放置。 所以对于一组询问，答案就是：$$[_{A + B - 2}^{n-1}] \times \binom{A + B - 2}{A - 1}$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=data*10+(ch^48), ch=getchar(); return data*w;&#125;const int mod(1e9 + 7), maxn(50010), maxk(210), K(201);int T, n, A, B, C[maxk][maxk], S[maxn][maxk];inline void Init()&#123; C[0][0] = 1; for(RG int i = 1; i &lt;= K; i++) &#123; C[i][0] = C[i][i] = 1; for(RG int j = 1; j &lt; i; j++) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; &#125; for(RG int i = 0; i &lt;= K; i++) S[i][i] = 1; for(RG int i = 2; i &lt;= maxn - 10; i++) for(RG int j = 1; j &lt; i &amp;&amp; j &lt;= K; j++) S[i][j] = (1ll * (i - 1) * S[i - 1][j] % mod + S[i - 1][j - 1]) % mod;&#125;int main()&#123; T = read(); Init(); while(T--) &#123; n = read(); A = read(); B = read(); if(A + B &gt; n + 1) &#123; puts("0"); continue; &#125; printf("%lld\n", 1ll * C[A + B - 2][A - 1] * S[n - 1][A + B - 2] % mod); &#125; return 0;&#125; 洛谷P1450 [HAOI2008]硬币购物预处理$f[i]$表示在不限制硬币数量的情况下购买价值为i的物品的方案数。跑一个完全背包就好了。 对于硬币个数的限制，考虑容斥：钦定若干种硬币使用$d_i+1$次，也就是钦定它超过限制。设被钦定的总费用为$x$，方案数就是$f[s-x]$。容斥一下，偶加奇减就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(100010);long long f[maxn], c[4], d[4], s;inline long long Cost(int i) &#123; return c[i] * (d[i] + 1); &#125;int T;int main()&#123; for(RG int i = 0; i &lt; 4; i++) c[i] = read(); f[0] = 1; for(RG int i = 0; i &lt; 4; i++) for(RG int j = c[i]; j &lt;= maxn - 10; j++) f[j] += f[j - c[i]]; T = read(); while(T--) &#123; for(RG int i = 0; i &lt; 4; i++) d[i] = read(); s = read(); long long ans = 0; for(RG int i = 0; i &lt; 16; i++) &#123; long long tot = 0; int pop_cnt = 0; for(RG int j = 0; j &lt; 4; j++) if(i &amp; (1 &lt;&lt; j)) tot += Cost(j), ++pop_cnt; if(s &gt;= tot) if(pop_cnt &amp; 1) ans -= f[s - tot]; else ans += f[s - tot]; &#125; printf("%lld\n", ans); &#125; return 0;&#125; 中国剩余定理CJOJ1272 韩信点兵中国剩余定理板子题。 设$M=\prod P_i,\;m_i=\frac{M}{p_i},\;t_im_i\equiv1\;(mod\;P_i)$ 可以发现$a_it_im_i\equiv0(mod\;m_i),\;a_it_im_i\equiv a_i(mod\;P_i)$ 所以答案就是$\sum a_it_im_i\;mod\;M$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline __int128 read()&#123; __int128 data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(20);__int128 p[maxn], a[maxn], M, m[maxn], ans, n, k;inline void exgcd(__int128 a, __int128 b, __int128 &amp;gcd, __int128 &amp;x, __int128 &amp;y)&#123; !b ? (gcd = a, x = 1, y = 0) : (exgcd(b, a % b, gcd, y, x), y -= x * (a / b));&#125;inline void CRT()&#123; static __int128 x, y, g; for(RG int i = 1; i &lt;= k; i++) &#123; m[i] = M / p[i]; exgcd(m[i], p[i], g, x, y); if(a[i] % g) &#123; ans = -1; return; &#125; x *= a[i] / g; ans = (ans + (x + M) % M * m[i] % M) % M; &#125; if(n &lt; ans) ans = -1; else ans = (n - ans) % M;&#125;int main()&#123; n = read(); k = read(); M = 1; for(RG int i = 1; i &lt;= k; i++) M *= (p[i] = read()), a[i] = read(); CRT(); printf("%lld\n", ans); return 0;&#125; BSGS洛谷P2485 [SDOI2011]计算器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define RG register#define cant "Orz, I cannot find x!"using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;template&lt;int MOD, int MAXN&gt;class hash&#123; private: struct link &#123; int next, key, val; &#125; e[MAXN]; int head[MOD], e_num; inline void Add(int pos, int key, int val) &#123; e[++e_num]=(link)&#123;head[pos], key, val&#125;; head[pos]=e_num; &#125; public: hash() &#123; clear(); &#125; inline void clear() &#123; memset(head, 0, sizeof(head)); e_num=0; &#125; inline void insert(int x, int v) &#123; Add(x%MOD, x, v); &#125; inline int operator[] (int x) &#123; for(RG int i=head[x%MOD];i;i=e[i].next) if(e[i].key==x) return e[i].val; return -1; &#125;&#125;;hash&lt;100007, 1000000&gt; get;int fastpow(RG int x, RG int y, RG int mod)&#123; int base=x%mod, ans=1; while(y) &#123; if(y&amp;1) ans=(1ll*ans*base)%mod; base=(1ll*base*base)%mod; y&gt;&gt;=1; &#125; return ans;&#125;int T, L;inline int gcd(RG int x, RG int y)&#123; while(y) y^=x^=y^=x%=y; return x;&#125;inline void BSGS(int a, int b, int p)&#123; if(!a%p) &#123; puts(cant); return; &#125; bool tag=true; get.clear(); int m=ceil(sqrt(p)), ans=b%p; get.insert(ans, 0); for(RG int i=1;i&lt;=m;i++) &#123; ans=1ll*ans*a%p; get.insert(ans, i); &#125; RG int t=fastpow(a, m, p); ans=t; for(RG int i=1; i&lt;=m; i++, ans=1ll*ans*t%p) if(~get[ans]) &#123; RG int k=i*m-get[ans]; k=(k%p+p)%p; printf("%d\n", k); tag=false; break; &#125; if(tag) puts(cant);&#125;int main()&#123; T=read(); L=read(); while(T--) &#123; RG int y=read(), z=read(), p=read(); if(L==1) printf("%d\n", fastpow(y, z, p)); else if(L==2) &#123; int e=gcd(y, p); if(z%e) puts(cant); else printf("%lld\n", ((z%p)*1ll*fastpow(y, p-2, p))%p); &#125; else BSGS(y%p, z%p, p); &#125; return 0;&#125; 矩阵乘法洛谷P1939 【模板】矩阵加速（数列）设$f[0],f[1],f[2]$表示当前项、前一项和前两项，设转移一步之后为$g[0],g[1],g[2],$则： $g[0]=f[0]+f[2],g[1]=f[0],g[2]=f[1]$，可以推出转移矩阵：$$\left[\begin{matrix}1 &amp; 1 &amp; 0 \0 &amp; 0 &amp; 1 \1 &amp; 0 &amp; 0\end{matrix}\right]$$ 矩阵快速幂即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define RI register intusing namespace std;typedef long long ll;const int mo=1e9+7;struct Matrix&#123; private: int a[110][110]; int n, MOD; public: Matrix(int mod, int an) :n(an) &#123; MOD=mod; memset(a, 0, sizeof(a)); &#125; inline int* operator [](int x) &#123; return a[x]; &#125; inline Matrix operator *(Matrix &amp;b) &#123; Matrix c(MOD,n); for(RI i=0;i&lt;n;i++) for(RI j=0;j&lt;n;j++) for(RI k=0;k&lt;n;k++) c[i][k]=(c[i][k]+1ll*a[i][j]*b[j][k])%MOD; return c; &#125; inline Matrix operator ^(ll k) &#123; Matrix base=*this; Matrix ans(MOD,n); for(RI i=0;i&lt;n;i++) ans[i][i]=1; while(k) &#123; if(k&amp;1) ans=ans*base; base=base*base; k&gt;&gt;=1; &#125; return ans; &#125;&#125;;inline ll read()&#123; ll data=0,w=1; char ch=0; while(ch!='-' &amp;&amp; (ch&lt;'0' || ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1,ch=getchar(); while(ch&gt;='0' &amp;&amp; ch&lt;='9') data=data*10+ch-'0',ch=getchar(); return data*w;&#125;ll n,t;int main()&#123; t=read(); Matrix S(mo,3); Matrix T(mo,3); while(t--) &#123; n=read(); if(n==1||n==2||n==3) &#123; puts("1"); continue; &#125; T[0][0]=T[2][0]=T[0][1]=T[1][2]=1; S[0][0]=S[0][1]=S[0][2]=1; Matrix &amp;&amp;ans=(T^(n-3)); Matrix &amp;&amp;ans2=S*ans; printf("%d\n",ans2[0][0]); &#125; return 0;&#125; 高斯消元洛谷P4035 [JSOI2008]球形空间产生器我们学过一个公式： $(x-a)^2+(y-b)^2=r^2$，其中$(x,y)$是圆上的一点，$(a,b)$为圆心，$r$为半径。$$\Rightarrow x^2-2xa+a^2+y^2-2yb+b^2=r^2 \\Rightarrow -2xa-2yb+(a^2+b^2-r^2)=-x^2-y^2$$我们可以令$x_1=a,x_2=b,x_3=(a^2+b^2-r^2)$，这样一来，我们就能得到$n+1$个形如$ax_1+bx_2+cx_3+…+x_{n+1}=k$的方程。$n$维坐标$+1$个常量，共$n+1$个未知数，有$n+1$个方程，用高斯-约旦消元法解方程即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;int n;double a[20][20];inline void Gauss()&#123; for(RG int i = 1, k = i; i &lt;= n; i++, k = i) &#123; for(RG int j = k + 1; j &lt;= n; j++) if(fabs(a[k][i]) &lt; fabs(a[j][i])) k = j; swap(a[i], a[k]); for(RG int j = i + 1; j &lt;= n + 1; j++) a[i][j] /= a[i][i]; a[i][i] = 1.; for(RG int j = 1; j &lt;= n; j++) &#123; if(i == j) continue; for(k = i + 1; k &lt;= n + 1; k++) a[j][k] -= a[j][i] * a[i][k]; a[j][i] = 0; &#125; &#125;&#125;#define sqr(x) ((x) * (x))int main()&#123; n = read() + 1; for(RG int i = 1; i &lt;= n; i++) &#123; for(RG int j = 1; j &lt; n; j++) scanf("%lf", &amp;a[i][j]), a[i][n + 1] -= sqr(a[i][j]), a[i][j] *= -2.; a[i][n] = 1; &#125; Gauss(); for(RG int i = 1; i &lt; n; i++) printf("%.3lf ", a[i][n + 1]); return 0;&#125; 洛谷P2973 [USACO10HOL]赶小猪设$f[i]$表示炸弹在第$i$个点爆炸的概率，显然$f[1]+…+f[n]=1$。 可以发现炸弹在$i$号点爆炸的概率正比于$i$号点的期望经过次数。所以有：$$f[i] = \sum\frac{f[j]×(1-\frac{p}{q})}{deg[j]}$$其中$i,j$间有边，$deg[j]$表示$j$的度数，$i&gt;1$。高斯消元即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(310);const long double eps(1e-15);int n, m, p, q, deg[maxn], g[maxn][maxn];long double P, a[maxn][maxn];inline void Gauss()&#123; for(RG int i = 1, k = i; i &lt;= n; i++, k = i) &#123; for(RG int j = k + 1; j &lt;= n; j++) if(fabs(a[k][i]) + eps &lt; fabs(a[j][i])) k = j; swap(a[i], a[k]); for(RG int j = i + 1; j &lt;= n + 1; j++) a[i][j] /= a[i][i]; a[i][i] = 1.; for(RG int j = 1; j &lt;= n; j++) &#123; if(i == j) continue; for(RG int k = i + 1; k &lt;= n + 1; k++) a[j][k] -= a[j][i] * a[i][k]; a[j][i] = 0.; &#125; &#125;&#125;int main()&#123; n = read(); m = read(); p = read(); q = read(); P = (long double)p / q; for(RG int i = 1, x, y; i &lt;= m; i++) x = read(), y = read(), g[x][y] = g[y][x] = 1, ++deg[x], ++deg[y]; for(RG int i = 1; i &lt;= n; i++) a[i][i] = 1; for(RG int i = 1; i &lt;= n; i++) for(RG int j = 1; j &lt;= n; j++) if(g[i][j]) a[i][j] -= (1. - P) / deg[j]; a[1][n + 1] = 1; Gauss(); for(RG int i = 1; i &lt;= n; i++) printf("%.9Lf\n", a[i][n + 1] * P); return 0;&#125; 同余类最短路洛谷P2662 牛场围栏可以先求出哪些长度的木板是可以使用的。然后。。。然后怎么做？ 设$s$是最短的可以使用的木板，如果我们能拼出长度为$g$的木板，我们就能拼出长度为$g,g+s,g+2×s…$的所有木板。 可以这样：设$f[i]$表示能拼出的、长度$\%s=i$的最短木板，显然$f[i],f[i]+s…$都可以被拼出。所以答案就是$max(f[0…s-1])$。$f$数组可以用类似最短路的方法求出。 有没有一种似曾相识的感觉？给定$a,b$，问最大的$x$使得$x$不能被非负整数个$a,b$表示出来。 小凯的疑惑？ 运用同余类最短路的思想，我们可以方便地证明小凯的疑惑中的结论：钦定$a&lt;b$，则$f[((a-b)\%a+a)\%a]=a\times b-b$。所以$a\times b-a-b$是最后一个不能被拼出的数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(5010);int n, m, len[maxn], cnt, dis[maxn];bool vis[maxn], h[maxn];inline int gcd(int x, int y)&#123; while(y) y ^= x ^= y ^= x %= y; return x;&#125;inline int Dijkstra()&#123; clear(dis, 0x7f); dis[0] = 0; for(RG int i = 2; i &lt;= maxn - 10; i++) if(h[i]) len[++cnt] = i; int mod = len[1]; for(RG int T = 1; T &lt;= mod; T++) &#123; int x = -1; for(RG int i = 0; i &lt; mod; i++) if(!vis[i] &amp;&amp; (x == -1 || dis[i] &lt; dis[x])) x = i; if(x == -1) break; vis[x] = true; for(RG int i = 2, to; i &lt;= cnt; i++) if(!vis[to = (x + len[i]) % mod]) dis[to] = min(dis[to], dis[x] + len[i]); &#125; for(RG int i = 1; i &lt; mod; i++) dis[i] -= mod; return *max_element(dis + 1, dis + mod);&#125;int main()&#123; n = read(); m = read(); int g = 0; for(RG int i = 1, l; i &lt;= n; i++) &#123; l = read(); for(RG int j = 0; j &lt;= m; j++) h[l - j] = 1, g = gcd(l - j, g); &#125; if(h[1] || g &gt; 1) return puts("-1") &amp; 0; else return printf("%d\n", Dijkstra()) &amp; 0;&#125; POJ3539 Elevator钦定$a=min(a,b,c)$，按照之前的方法求出$f[0],…,f[a-1]$，答案就是： $$h-\sum_{i=0}^{a-1}\left{\begin{array}\lfloor \frac{h}{a} \rfloor + [i \leq h \% a],\;f[i] \geq h \\lfloor \frac{f[i]}{a} \rfloor,\;f[i] &lt; h\end{array}\right.$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(1e5 + 10);long long h, ans, dis[maxn];struct edge &#123; int next, to, dis; &#125; e[maxn &lt;&lt; 1];int head[maxn], e_num, a, b, c, vis[maxn];inline void add_edge(int from, int to, int dis)&#123; e[++e_num].next = head[from]; e[e_num].to = to; e[e_num].dis = dis; head[from] = e_num;&#125;priority_queue&lt;pair&lt;long long, int&gt;, vector&lt;pair&lt;long long, int&gt; &gt;, greater&lt;pair&lt;long long, int&gt; &gt; &gt; q;inline void Dijkstra()&#123; clear(dis, 0x3f); dis[1 % a] = 1; q.push(make_pair(1, 1 % a)); while(!q.empty()) &#123; int x = q.top().second; q.pop(); if(vis[x]) continue; vis[x] = 1; for(RG int i = head[x]; i; i = e[i].next) &#123; int to = e[i].to; if(dis[to] &gt; dis[x] + e[i].dis) &#123; dis[to] = dis[x] + e[i].dis; q.push(make_pair(dis[to], to)); &#125; &#125; &#125;&#125;int main()&#123; h = read&lt;long long&gt;(); a = read&lt;int&gt;(); b = read&lt;int&gt;(); c = read&lt;int&gt;(); if(a &gt; b) swap(a, b); if(a &gt; c) swap(a, c); for(RG int i = 0; i &lt; a; i++) add_edge(i, (i + b) % a, b), add_edge(i, (i + c) % a, c); Dijkstra(); for(RG int i = 0; i &lt; a; i++) if(dis[i] &lt;= h) ans += 1ll * (h - dis[i]) / a + 1; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>组合数</tag>
        <tag>数论</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-09-30考试]]></title>
    <url>%2F2018%2F10%2F01%2F2018-09-30%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[结果题面题解T1此题数据较弱,一些错误的做法也能通过全部数据。本题只要记录一个前缀$OR$和$Pre_i$以及后缀$OR和$Suf_i$,枚举修改的位置即可。 T2首先对于一个人$i$,显而易见,他所能到达的格子一定是$gcd(a_i,n)$的倍数。只要枚举$n$的约数,令当前枚举到的数为$d$,若存在一个$i$, 使得$gcd(a_i,n)|d$说明所有$gcd(i, n) = d$的格子都能被到达,答案加上$φ(\frac{n}{d})$即可。 T3状压$dp$, 首先把表达式的树形结构建出来, $dp_{i,j}$表示第$i$个表达式中,当$ABCD$的值分别为$m$个条件中的值的时候, 表达式的结果为$j$的表达式的数目。通过AND, OR卷积进行转移, 利用$FWT$或分治乘法优化即可。 代码T11234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;const int maxn(100010);long long tree[maxn &lt;&lt; 2], a[maxn], ans;int n, x;#define son(i) ((root &lt;&lt; 1) | i)inline void build(int root = 1, int l = 1, int r = n)&#123; if(l == r) &#123; tree[root] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(son(0), l, mid); build(son(1), mid + 1, r); tree[root] = tree[son(0)] | tree[son(1)];&#125;inline long long query(int ql, int qr, int root = 1, int l = 1, int r = n)&#123; if(qr &lt; l || r &lt; ql) return 0; if(ql &lt;= l &amp;&amp; r &lt;= qr) return tree[root]; int mid = (l + r) &gt;&gt; 1; return query(ql, qr, son(0), l, mid) | query(ql, qr, son(1), mid + 1, r);&#125;int main()&#123; file(poker); n = read(); x = read(); for(RG int i = 1; i &lt;= n; i++) a[i] = read(); build(); ans = max(query(2, n) | (a[1] * x), query(1, n - 1) | (a[n] * x)); for(RG int i = 2; i &lt; n; i++) ans = max(ans, query(1, i - 1) | query(i + 1, n) | (a[i] * x)); printf("%lld\n", ans); return 0;&#125; T260分123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;inline int gcd(int x, int y)&#123; while(y) y ^= x ^= y ^= x %= y; return x;&#125;const int maxn(60);int n, m, a[maxn], ans;int main()&#123; file(running); n = read(); m = read(); ans = n - 1; for(RG int i = 1; i &lt;= m; i++) a[i] = gcd(read(), n); for(RG int i = 1; i &lt; n; i++) for(RG int j = 1; j &lt;= m; j++) if(!(i % a[j])) &#123; --ans; break; &#125; printf("%d\n", ans); return 0;&#125; T320分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data = 0, w = 1; char ch = getchar(); while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = data * 10 + (ch ^ 48), ch = getchar(); return data*w;&#125;char s[1000];int A[20], B[20], C[20], D[20], E[20], len, q[1000], cnt, ans, m;int val[300];int Calc(int beg, int end)&#123; if(end - beg == 0) return val[s[beg]]; int pos = end, x = 1; for(RG int i = beg + 1; i &lt;= end; i++) &#123; if(s[i] == ')') x--; if(s[i] == '(') x++; if(!x) &#123; pos = i; break; &#125; &#125; int a = Calc(beg + 1, pos - 1), b = Calc(pos + 3, end - 1); if(s[pos + 1] == '|') return a | b; else return a &amp; b;&#125;inline bool check()&#123; for(RG int i = 1; i &lt;= m; i++) &#123; val['a'] = !(val['A'] = A[i]); val['b'] = !(val['B'] = B[i]); val['c'] = !(val['C'] = C[i]); val['d'] = !(val['D'] = D[i]); if(Calc(1, len) != E[i]) return false; &#125; // printf("%s\n", s + 1); return true;&#125;void dfs(int x)&#123; if(x == cnt + 1) &#123; if(check()) ++ans; return; &#125; if(s[q[x] - 1] == ')' &amp;&amp; s[q[x] + 1] == '(') &#123; s[q[x]] = '&amp;'; dfs(x + 1); s[q[x]] = '|'; dfs(x + 1); &#125; else &#123; s[q[x]] = 'A'; dfs(x + 1); s[q[x]] = 'B'; dfs(x + 1); s[q[x]] = 'C'; dfs(x + 1); s[q[x]] = 'D'; dfs(x + 1); s[q[x]] = 'a'; dfs(x + 1); s[q[x]] = 'b'; dfs(x + 1); s[q[x]] = 'c'; dfs(x + 1); s[q[x]] = 'd'; dfs(x + 1); &#125;&#125;int main()&#123; file(calculate); scanf("%s", s + 1); len = strlen(s + 1); for(RG int i = 1; i &lt;= len; i++) if(s[i] == '?') q[++cnt] = i; m = read(); for(RG int i = 1; i &lt;= m; i++) A[i] = read(), B[i] = read(), C[i] = read(), D[i] = read(), E[i] = read(); dfs(1); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-09-27考试]]></title>
    <url>%2F2018%2F09%2F27%2F2018-09-27%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[序莫名220??? 结果题面题解T1二分答案 + spfa check T2DP，设$f_{i,0/1}$表示前$i$个时刻，当前这个时刻是否打下鸟的最大值然后就可以乱搞了 T3结论题??? 代码T1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(110);const int dx[] = &#123;1, 0, -1, 0&#125;;const int dy[] = &#123;0, 1, 0, -1&#125;;int inque[maxn][maxn], n, m, sx, sy, tx, ty, can[maxn][maxn];double dis[maxn][maxn], s;queue&lt;pair&lt;int, int&gt; &gt; q;inline double spfa(double k)&#123; for(RG int i = 1; i &lt;= n; i++) for(RG int j = 1; j &lt;= m; j++) dis[i][j] = 1e15; clear(inque, 0); dis[sx][sy] = 0; inque[sx][sy] = 1; q.push(make_pair(sx, sy)); while(!q.empty()) &#123; pair&lt;int, int&gt; x = q.front(); q.pop(); int xx = x.first, xy = x.second; for(RG int i = 0; i &lt; 4; i++) &#123; int tx = xx + dx[i], ty = xy + dy[i]; double ex = (i &amp; 1) ? 1. : k; if(tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m &amp;&amp; !can[tx][ty] &amp;&amp; dis[tx][ty] &gt; dis[xx][xy] + ex) &#123; dis[tx][ty] = dis[xx][xy] + ex; if(!inque[tx][ty]) inque[tx][ty] = 1, q.push(make_pair(tx, ty)); &#125; &#125; inque[xx][xy] = 0; &#125; return dis[tx][ty];&#125;int main()&#123; file(maze); n = read(); m = read(); sx = read(); sy = read(); tx = read(); ty = read(); for(RG int i = 1; i &lt;= n; i++) for(RG int j = 1; j &lt;= m; j++) can[i][j] = read(); scanf("%lf", &amp;s); double l = -0.1, r = 1e5 + 1.; while(r - l &gt; 1e-5) &#123; double mid = (l + r) * .5; if(spfa(mid) &lt; s) l = mid; else r = mid; &#125; printf("%.3lf\n", l); return 0;&#125; T212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=data*10+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010), maxl(500010);int tree[maxl &lt;&lt; 2], n, _max, lazy[maxl &lt;&lt; 2], k;#define son(i) (root &lt;&lt; 1 | i)inline void pushdown(int root, int l, int r)&#123; if(l == r) return; if(!lazy[root]) return; tree[son(0)] += lazy[root]; lazy[son(0)] += lazy[root]; tree[son(1)] += lazy[root]; lazy[son(1)] += lazy[root]; lazy[root] = 0;&#125;inline void update(int ql, int qr, int val, int root = 1, int l = 1, int r = _max + 1)&#123; if(r &lt; ql || qr &lt; l) return; if(ql &lt;= l &amp;&amp; r &lt;= qr) &#123; tree[root] += val; lazy[root] += val; return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(root, l, r); update(ql, qr, val, son(0), l, mid); update(ql, qr, val, son(1), mid + 1, r); tree[root] = max(tree[son(0)], tree[son(1)]);&#125;inline int query(int ql, int qr, int root = 1, int l = 1, int r = _max + 1)&#123; if(r &lt; ql || qr &lt; l) return -INT_MAX; if(ql &lt;= l &amp;&amp; r &lt;= qr) return tree[root]; int mid = (l + r) &gt;&gt; 1; pushdown(root, l, r); return max(query(ql, qr, son(0), l, mid), query(ql, qr, son(1), mid + 1, r));&#125;struct line &#123; int l, r; &#125; a[maxn];vector&lt;int&gt; end_s[maxl];int g[maxl], cnt, c[maxl];int main()&#123; file(bird); n = read(); k = read(); for(RG int i = 1; i &lt;= n; i++) &#123; a[++cnt].l = max(read(), 0); a[cnt].r = read(); if(a[cnt].r &lt; 0) --cnt; _max = max(_max, a[cnt].r); &#125; for(RG int i = 1; i &lt;= cnt; i++) end_s[a[i].r + 1].push_back(i), update(a[i].l + 1, a[i].r + 1, -1), ++c[a[i].l], --c[a[i].r + 1]; int tmp = query(1, 1); update(1, 1, -tmp); int sum = c[0]; for(RG int i = 1; i &lt;= _max; i++) &#123; g[i] = max(g[i - 1], query(i, i) + sum); while(!end_s[i].empty()) &#123; int tmp = end_s[i].back(); end_s[i].pop_back(); update(a[tmp].l + 1, a[tmp].r + 1, 1); &#125; sum += c[i]; int q = (i - k + 1) &gt; 0 ? query(1, i - k + 1) : 0; update(i + 1, i + 1, q + sum); &#125; printf("%d\n", max(g[_max], query(_max + 1, _max + 1) + sum)); return 0;&#125; T3None]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】二分图匹配]]></title>
    <url>%2F2018%2F09%2F23%2F%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题面题解这题被我强行用来练习网络流… 建立源点和汇点，连接二分图的两边，跑最大流即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(2020), maxm(1000010);struct edge &#123; int next, to, cap; &#125; e[maxm &lt;&lt; 1];int head[maxn], e_num = -1, n, m, s, t, E;inline void add_edge(int from, int to, int cap)&#123; e[++e_num] = (edge) &#123;head[from], to, cap&#125;; head[from] = e_num;&#125;inline void add(int from, int to, int cap)&#123; add_edge(from, to, cap); add_edge(to, from, 0);&#125;int lev[maxn], cur[maxn], q[maxn], tail;inline int bfs()&#123; clear(lev, 0); q[tail = lev[s] = 1] = s; for(int h = 1; h &lt;= tail; h++) &#123; int x = q[h]; for(RG int i = head[x]; ~i; i = e[i].next) &#123; int to = e[i].to; if(lev[to] || (!e[i].cap)) continue; lev[to] = lev[x] + 1; q[++tail] = to; &#125; &#125; return lev[t];&#125;int dfs(int x, int f)&#123; if(x == t) return f; RG int ans = 0, cap; for(RG int &amp;i = cur[x]; ~i; i = e[i].next) &#123; int to = e[i].to; if(e[i].cap &amp;&amp; lev[to] == lev[x] + 1) &#123; cap = dfs(to, min(f - ans, e[i].cap)); e[i].cap -= cap; e[i ^ 1].cap += cap; ans += cap; if(ans == f) break; &#125; &#125; return ans;&#125;inline int Dinic()&#123; RG int ans = 0; while(bfs()) &#123; for(RG int i = 1; i &lt;= n + m + 2; i++) cur[i] = head[i]; ans += dfs(s, INT_MAX); &#125; return ans;&#125;int main()&#123; clear(head, -1); n = read(); m = read(); E = read(); s = 1; t = n + m + 2; for(RG int i = 1, a, b; i &lt;= E; i++) &#123; a = read(); b = read(); if(b &gt; m || a &gt; n) continue; add(a + 1, b + n + 1, 1); &#125; for(RG int i = 1; i &lt;= n; i++) add(s, i + 1, 1); for(RG int i = 1; i &lt;= m; i++) add(i + n + 1, t, 1); printf("%d\n", Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ2957】楼房重建]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[题面题解这是一种线段树套路，$CJK$美其名曰”楼房重建版线段树” 先把每个点的高度转为斜率我们用线段树维护区间的最长上升子序列合并两个儿子的信息时分最大值大于或小于当前节点左儿子最大值考虑即可 时间复杂度$O(nlog^2n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010);int n, m, tree[maxn &lt;&lt; 2];double val[maxn &lt;&lt; 2];#define son(i) (root &lt;&lt; 1 | i)inline int calc(double v, int root, int l, int r)&#123; if(l == r) return val[root] &gt; v; int mid(l + r &gt;&gt; 1); if(val[son(0)] &lt;= v) return calc(v, son(1), mid + 1, r); return tree[root] - tree[son(0)] + calc(v, son(0), l, mid);&#125;inline void modify(int pos, double v, int root = 1, int l = 1, int r = n)&#123; if(l == r) &#123; tree[root] = 1, val[root] = v; return; &#125; int mid(l + r &gt;&gt; 1); if(pos &lt;= mid) modify(pos, v, son(0), l, mid); else modify(pos, v, son(1), mid + 1, r); val[root] = max(val[son(0)], val[son(1)]); tree[root] = tree[son(0)] + calc(val[son(0)], son(1), mid + 1, r);&#125;int main()&#123; n = read(); m = read(); while(m--) &#123; int x = read(), y = read(); modify(x, (double)y / x); printf("%d\n", tree[1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网NOIP赛前集训营-提高组（第一场）中位数]]></title>
    <url>%2F2018%2F09%2F09%2Fnew-coder-TG1A%2F</url>
    <content type="text"><![CDATA[题面题解 对于第一档数据,可以枚举选取的合法的子区间,再重新排序, 直接得到中位数。时间复杂度$O(n^3)$。 对于第二档数据,可以枚举子区间的左端点,依次往右增加新的数,现在要做的就是往一个有序列表里加数,然后查询第k小的值。这个可以用平衡树维护。总复杂度就是$O(n^2logn)$。 对于第三档数据,直接枚举最终可能的答案x。把数字大于等于$x$的记为1,小于$x$的记为-1。检验是否存在和$&gt;=0$的区间。可以维护一个前缀和的前缀最大值。时间复杂度$O(Mn)$, M为不同的数的个数。 正解:发现第三档数据中的$x$其实是可以二分的。那么二分答案$x$,用上面的方法检验。时间复杂度$O(nloga_i)$。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define RG registerusing namespace std;multiset&lt;int&gt; s;const int maxn(1e5 + 10);int n, a[maxn], len, ans, b[maxn];inline bool check(int mid)&#123; for(RG int i=1;i&lt;=n;i++) b[i] = a[i] &lt; mid ? -1 : 1; int _min = INT_MAX; for(RG int i=1;i&lt;=n;i++) &#123; b[i] += b[i-1]; if(i &gt;= len) &#123; _min = min(_min, b[i-len]); if(b[i] - _min &gt; 0) return true; &#125; &#125; return false;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;len); for(RG int i=1;i&lt;=n;i++) scanf("%d", &amp;a[i]); long long l = 1, r = 1e9 + 1, ans = -1; while(l &lt;= r) &#123; int mid((l + r) &gt;&gt; 1); if(check(mid)) ans = mid, l = mid + 1; else r = mid - 1; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI.AC[32] 排序]]></title>
    <url>%2F2018%2F09%2F08%2Fsort-in-NOI-AC%2F</url>
    <content type="text"><![CDATA[题面题解首先离散化 考虑如何翻转 用快排的方式可以将区间划分成两段$[l,\;mid],\;[mid+1,\;r]$ 可以将这一段序列转化成$01$序列 $&lt;=mid$的为$0$, $&gt;mid$的为$1$ 对于这个序列进行归并排序 具体来说, 归并前的序列为一个 [l, mid] [mid + 1, r] 0000…01111 00001…1111 那么将中间的$11110000$翻转即可 时间复杂度$O(nlog^2n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(50010);int n, a[maxn], b[maxn], c[maxn];vector&lt;pair&lt;int, int&gt; &gt; ans;void merge(int l, int r)&#123; if(l == r) return; int mid(l + r &gt;&gt; 1); merge(l, mid); merge(mid + 1, r); int pos_1 = mid + 1, pos_0 = mid; for(RG int i=l;i&lt;=mid;i++) if(c[i] == 1) &#123; pos_1 = i; break; &#125; for(RG int i=r;i&gt;mid;i--) if(c[i] == 0) &#123; pos_0 = i; break; &#125; if(pos_1 == mid + 1 || pos_0 == mid) return; reverse(c + pos_1, c + pos_0 + 1); reverse(a + pos_1, a + pos_0 + 1); ans.push_back(make_pair(pos_1, pos_0));&#125;void Div(int l, int r)&#123; if(l == r) return; int mid(l + r &gt;&gt; 1); for(RG int i=l;i&lt;=r;i++) c[i] = a[i] &lt;= mid ? 0 : 1; merge(l, r); Div(l, mid); Div(mid+1, r);&#125;inline int cmp(const int &amp;x, const int &amp;y) &#123; return a[x] &lt; a[y]; &#125;int main()&#123; n = read(); for(RG int i=1;i&lt;=n;i++) a[i] = read(), b[i] = i; sort(b + 1, b + n + 1, cmp); for(RG int i=1;i&lt;=n;i++) a[b[i]] = i; Div(1, n); for(RG vector&lt;pair&lt;int, int&gt; &gt;::iterator it = ans.begin(); it != ans.end(); ++it) printf("%d %d\n", it-&gt;first, it-&gt;second); puts("-1 -1"); return 0;&#125;]]></content>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ2598】Match Throwing Game]]></title>
    <url>%2F2018%2F08%2F15%2F%E3%80%90POJ2598%E3%80%91%E6%89%94%E7%81%AB%E6%9F%B4%2F</url>
    <content type="text"><![CDATA[题面题解忘了，只记得是用$sin(x)$的积分搞还要进行伯努利实验 代码123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define RG registerusing namespace std;const double PI(acos(-1));double L, p, sum[1010];int x, y;inline double Bernulli(int n, int m, double p, double q) &#123; return log(p) * m + log(q) * (n - m) + sum[n] - sum[n-m] - sum[m]; &#125;int main()&#123; for(RG int i=1;i&lt;1010;i++) sum[i] = sum[i-1] + log(i); while(~scanf("%lf", &amp;L)) &#123; if(L &lt; 1) p = 2 * L; else &#123; double k = asin(double(1 / L)); p = 2 * L * (1 - cos(k)) + PI - 2 * k; &#125; p /= PI; y = (x = int(p * 1000)) + 1; double l = Bernulli(1000, x, p, 1-p), r = Bernulli(1000, y, p, 1-p); if(l &lt; r) swap(x, y); printf("%d\n", x); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘]]></title>
    <url>%2F2018%2F08%2F12%2F%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[线段树的错误 懒标记不清空 懒标记下放得慢 指针的问题各种解决方案：不用 数组大小maxn = [] + 10]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-08-11考试]]></title>
    <url>%2F2018%2F08%2F11%2F2018-08-11%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[序考试爆炸祭…暴力分那么高，打什么正解 结果题面T1T2T3题解T1一眼二分答案，结果写错了爆5分 T2一眼看到这个: 对于所有编号为奇数的数据:$a_i=0, i∈[0,7]$; 于是大力贪心骗到了$65pts$正解差分约束？？？我还看到过？？？ T3我要好好写一下这一题的题解暴力80分我还来想正解，SHIFT 最近学了一个叫做$Generating\;Function$的东西于是对于一个区间$[l, r]$，有 $$G(x)=\prod_{i=l}^r(a_ix+1)$$因为$k&lt;=10$所以可以维护母函数前$10$项系数$pushup$很好写，就是一个多项式乘法$pushdown$的取反很好写，只要考虑奇数项区间加则不那么好写，(毒瘤线段树)令$[x^k]$表示$G(x)$中$x^k$的系数$$\therefore[x^k] = \sum_{i_1&lt;i_2&lt;i_3&lt;…&lt;i_k}\prod_{j=1}^ka_{i_j}$$$$\because new[x^k] = \sum_{i_1&lt;i_2&lt;i_3&lt;…&lt;i_k}\prod_{j=1}^k(a_{i_j} + c)$$$\therefore$对于每一个展开式中的$l$$\prod_{j=1}^la_{i_j}$与$\prod_{j=1}^{k-l}a_{i_j^{,}}$一一对应又$\because \prod_{j=1}^{k-l}a_{i_j^{,}}$有$\binom{len-l}{k-l}$个$\therefore$这里贡献的答案为$c^{k-l}\binom{len-l}{k-l}\prod_{j=1}^la_{i_j}$$$\therefore new[x^k]=\sum_{j=0}^{k-1}\binom{len-j}{k-j}[x^j]c^{k-j}$$于是就可以$pushdown$了注意指针的问题!!! 代码T1最后AC的代码让我自己都懵1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(1e5+10);int x[maxn], y[maxn], n, m, qx, qy;inline bool check(int mid)&#123; long long a = 1ll * y[mid] * qx; long long b = 1ll * x[mid] * qy; long long c = 1ll * x[mid] * y[mid]; return c &lt;= (a + b);&#125;int main()&#123; n = read(); for(RG int i=1;i&lt;=n;i++) x[i]=read(); for(RG int i=1;i&lt;=n;i++) y[i]=read(); sort(x+1, x+n+1); sort(y+1, y+n+1); m = read(); while(m--) &#123; qx = read(); qy = read(); int l = 0, r = n; while(l&lt;r) &#123; int mid(l+r&gt;&gt;1); if(check(mid + 1)) l = mid + 1; else r = mid; &#125; printf("%d\n", l); &#125; return 0;&#125; T2没有 T3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(50010), mod(1e9+7);int tree[maxn &lt;&lt; 2][11], sum[maxn &lt;&lt; 2], n, a[maxn], m, c[maxn][11];bool mul[maxn &lt;&lt; 2];inline int fastpow(int x, int y)&#123; int ans=1; while(y) &#123; if(y&amp;1) ans=1ll*ans*x%mod; x=1ll*x*x%mod; y&gt;&gt;=1; &#125; return ans;&#125;#define son(i) ((root&lt;&lt;1)|i)inline void pushup(int root, int l, int r)&#123; clear(tree[root], 0); int mid=l+r&gt;&gt;1, l1=min(mid-l+1, 10), l2=min(r-mid, 10); for(RG int i=0;i&lt;=l1;i++) for(RG int j=0;j&lt;=l2 &amp;&amp; i+j&lt;=10;j++) tree[root][i+j]=(1ll*tree[root][i+j]+1ll*tree[son(0)][i]*tree[son(1)][j]%mod)%mod;&#125;void build(int root=1, int l=1, int r=n)&#123; if(l==r) &#123; tree[root][1]=a[l]; tree[root][0]=1; return; &#125; int mid(l+r&gt;&gt;1); build(son(0), l, mid); build(son(1), mid+1, r); pushup(root, l, r);&#125;inline void dowork(int root, int l, int r, int v)&#123; int len=r-l+1, cnt=min(len, 10); for(RG int i=cnt;~i;i--) for(RG int j=i-1;~j;j--) tree[root][i]=(1ll*tree[root][i]+1ll*(1ll*tree[root][j]*c[len-j][i-j]%mod)*fastpow(v, i-j)%mod)%mod; sum[root]=(1ll*sum[root]+1ll*v)%mod;&#125;inline void rev(int root)&#123; for(RG int i=1;i&lt;=10;i++) if(i &amp; 1) tree[root][i]=(mod-tree[root][i])%mod; mul[root]^=1; sum[root]=(mod-sum[root])%mod;&#125;inline void pushdown(int root, int l, int r)&#123; if(l==r) return; if(mul[root]) &#123; mul[root]=0; rev(son(0)); rev(son(1)); &#125; if(sum[root]!=0) &#123; int mid(l+r&gt;&gt;1); dowork(son(0), l, mid, sum[root]); dowork(son(1), mid+1, r, sum[root]); sum[root]=0; &#125;&#125;void update_add(int ql, int qr, int v, int root=1, int l=1, int r=n)&#123; if(r&lt;ql || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; dowork(root, l, r, v); return; &#125; pushdown(root, l, r); int mid(l+r&gt;&gt;1); update_add(ql, qr, v, son(0), l, mid); update_add(ql, qr, v, son(1), mid+1, r); pushup(root, l, r);&#125;void update_rev(int ql, int qr, int root=1, int l=1, int r=n)&#123; if(r&lt;ql || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; rev(root); return; &#125; pushdown(root, l, r); int mid(l+r&gt;&gt;1); update_rev(ql, qr, son(0), l, mid); update_rev(ql, qr, son(1), mid+1, r); pushup(root, l, r);&#125;int *query(int ql, int qr, int root=1, int l=1, int r=n)&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return tree[root]; pushdown(root, l, r); int mid=l+r&gt;&gt;1, *x=NULL, *y=NULL, *z; if(ql&lt;=mid) x=query(ql, qr, son(0), l, mid); if(qr&gt;mid) y=query(ql, qr, son(1), mid+1, r); if(x==NULL) return y; if(y==NULL) return x; z=new int[11]; clear(z, 0); for(RG int i=0;i&lt;=10;i++) for(RG int j=0;j&lt;=10 &amp;&amp; i+j&lt;=10;j++) z[i+j]=(1ll*z[i+j]+1ll*x[i]*y[j]%mod)%mod; return z;&#125;int main()&#123; n = read(); m = read(); c[0][0]=1; for(RG int i=1;i&lt;=n;i++) &#123; c[i][0]=1; for(RG int j=1;j&lt;=i &amp;&amp; j&lt;=10;j++) c[i][j]=(1ll*c[i-1][j-1]+1ll*c[i-1][j])%mod; &#125; for(RG int i=1;i&lt;=n;i++) a[i]=(1ll*read()+1ll*mod)%mod; build(); while(m--) &#123; int opt=read(), x=read(), y=read(), z; switch(opt) &#123; case 1: z=(1ll*read()+1ll*mod)%mod; update_add(x, y, z); break; case 2: update_rev(x, y); break; case 3: z=read(); printf("%d\n", *(query(x, y)+z)); break; &#125; &#125; return 0;&#125; 是不是很短]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-26考试]]></title>
    <url>%2F2018%2F06%2F02%2F2018-05-26%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[序T1为什么只有我推得那么奇怪… %%%AK巨佬HYJ 结果题面T1T2T3题解T1Method$1$由题: $ans$可以倒推 设当前$i=ans,\;a_1=x_i^2(i+1),\;b_1=ix_i$ $$\therefore a_1a+b_1b+c=-b_1-i$$ 令$p=-b_1-i,\;q=a_0-b_0,\;r=b_0-c_0$ 解得:$b=\frac{p-a_1q+r}{a_1+b_1+1}$ 可得上一次答案为$ans_1=b-b_0$ 倒推即可 但是会爆long long Method$2$由题: 设$a_1,\;b_1,\;x=ans_1$ $$\therefore a_1a_0+b_1(b_0+1)+c_1+i$$ $$=a_1a+b_1(b+1)+c+i-a_1x-b_1x-x$$ $$=-(a_1+b_1+1)x$$ 令$y=a_1a_0+b_1(b_0+1)+c_1+i$ $$\therefore x=-\frac{y}{a_1+b_1+1}$$ T2, T3太简单, 不讲 代码T1Method$2$12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(50010), maxq(500010);int a[maxq], b[maxq], s[maxn], n, cnt, ans[maxq];long long c[maxq];int main()&#123; n=read(); cnt=1; for(RG int i=1;i&lt;=n;i++) s[i]=read(); while(scanf("%d%d%lld", &amp;a[cnt], &amp;b[cnt], &amp;c[cnt])!=EOF) ++cnt; --cnt; ans[cnt-1]=-a[cnt]; for(RG int i=cnt-1;i-1;i--) &#123; long long a1=1ll*(ans[i]+1)*s[ans[i]]*s[ans[i]]; long long b1=1ll*ans[i]*s[ans[i]]; ans[i-1]=-(1ll*a1*a[i]+1ll*(b[i]+1)*b1+c[i]+ans[i])/(a1+b1+1); &#125; for(RG int i=1;i&lt;cnt;i++) printf("%d\n", ans[i]); return 0;&#125; T212345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010), mod(1e9+9);int n, m, x, ans;char s[3];struct node &#123; char a; int x; &#125; p[maxn];inline bool cmp(const node &amp;a, const node &amp;b) &#123; return a.x&lt;b.x; &#125;int main()&#123; n=read(); m=read(); ans=1; for(RG int i=1;i&lt;=m;i++) &#123; scanf("%s%d", s, &amp;x); p[i]=(node)&#123;s[0], x&#125;; &#125; sort(p+1, p+m+1, cmp); for(RG int i=2;i&lt;=m;i++) if(p[i].a^p[i-1].a) ans=1ll*ans*(p[i].x-p[i-1].x)%mod; printf("%d\n", ans); return 0;&#125; T3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(1010), maxm(10010);struct edge &#123; int next, to, dis; &#125; e[maxm &lt;&lt; 2];int head[maxn], e_num, n, ML, DL, a, b, c, dis[maxn], cnt[maxn];bool inque[maxn];inline void add_edge(int from, int to, int dis)&#123; e[++e_num]=(edge)&#123;head[from], to, dis&#125;; head[from]=e_num;&#125;queue&lt;int&gt; q;inline int spfa()&#123; inque[1]=cnt[1]=1; dis[1]=0; q.push(1); while(!q.empty()) &#123; int x=q.front(); q.pop(); if(cnt[x]&gt;=n) return -1; for(RG int i=head[x];i;i=e[i].next) &#123; int to=e[i].to; if(dis[x]+e[i].dis&lt;dis[to]) &#123; dis[to]=dis[x]+e[i].dis; if(!inque[to]) &#123; inque[to]=true; ++cnt[to]; if(cnt[to]&gt;=n) return -1; q.push(to); &#125; &#125; &#125; inque[x]=false; &#125; return dis[n]^dis[0]?dis[n]:-2;&#125;int main()&#123; clear(dis, 63); n=read(); ML=read(); DL=read(); for(RG int i=1;i&lt;=ML;i++) &#123; a=read(); b=read(); c=read(); add_edge(a, b, c); &#125; for(RG int i=1;i&lt;=DL;i++) &#123; a=read(); b=read(); c=read(); add_edge(b, a, -c); &#125; printf("%d\n", spfa()); return 0;&#125;]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于齐次数列通项公式的一点点看法]]></title>
    <url>%2F2018%2F05%2F17%2F%E5%85%B3%E4%BA%8E%E9%BD%90%E6%AC%A1%E6%95%B0%E5%88%97%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E7%9C%8B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[具体就是求特征方程啊。比如说： 情况一:$x$是一重根 $$a_n=2a_{n-1}+3a_{n-2}$$ 特征方程: $$x^2-2x-3=0$$ 所以 $$x_1=-1, x_2=3$$ $$&lt;=&gt;a_n=αx_1^n+βx_2^n$$ 将${a_n}$的初值代入即可。 情况二:$x$是$k$重根 则在通项内加入： $$x^n\sum_{i=0}^{k-1}ψn^i,\;n^0=1$$ 情况三:若一对$x$是共轭复根$a±b$ 则在通项内加入： $$r^n(cos(nθ)+sin(nθ)),\;θ=arctan(\frac{b}{a}),\;r=\sqrt{a^2+b^2}$$ Over]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【国家集训队】Crash的数字表格]]></title>
    <url>%2F2018%2F05%2F17%2F%E3%80%90%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%91Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题面今天的数学课上，Crash小朋友学习了最小公倍数(Least Common Multiple)。对于两个正整数a和b，$lcm(a, b)​$表示能同时整除a和b的最小正整数。例如，$lcm(6, 8) = 24​$。 回到家后，Crash还在想着课上学的东西，为了研究最小公倍数，他画了一张N×M的表格。每个格子里写了一个数字，其中第i行第j列的那个格子里写着数为$lcm(i, j)$。一个4×5的表格如下： 12341 2 3 4 52 2 6 4 103 6 3 12 154 4 12 4 20 看着这个表格，Crash想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当$N$和$M$很大时，Crash就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，Crash只想知道表格里所有数的和 $mod\;20101009$ 的值。 题解简化题意： 给定$n$,$m$ 求 $\sum_{i=1}^n \sum_{j=1}^n lcm(i, j)$ 以下的一切都默认$n&lt;m$ 我们都知道$lcm(i,j)=\frac{ij}{gcd(i,j)}$ 所以所求化简 $$\sum_{i=1}^n\sum_{j=1}^m\frac{ij}{gcd(i,j)}$$ 看到$gcd(i,j)$很不爽，于是就再提出来 $$\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m[gcd(i, j)==d]\frac{ij}{d}$$ 也就是 $$\sum_{d=1}^n\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}[gcd(i, j)==1]ijd$$ 把$d$提出来 $$ans=\sum_{d=1}^nd\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}[gcd(i, j)==1]ij$$ 前面这一堆看起来管不了了 看后面的一段 $$\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}[gcd(i, j)==1]ij$$ 看到$\frac{n}{d}$这种东西很不爽呀 就写成这样吧。。 $$\sum_{i=1}^{x}\sum_{j=1}^{y}[gcd(i, j)==1]ij$$ 这种东西怎么求？ 令 $$f(d)=\sum_{i=1}^{x}\sum_{j=1}^{y}[gcd(i, j)==d]ij$$ 根据莫比乌斯反演的常见套路 设 $$g(d)=\sum_{i=1}^x\sum_{j=1}^y[d|gcd(i, j)]ij$$ 直接把$d$提出来 $$g(d)=d^2\sum_{i=1}^{\frac{x}{d}}\sum_{j=1}^{\frac{y}{d}}[1|gcd(i, j)]ij$$ $1|gcd(i, j)$是显然成立的 所以 $$g(d)=d^2\sum_{i=1}^{\frac{x}{d}}\sum_{j=1}^{\frac{y}{d}}ij$$ 这玩意明显可以$O(1)$求（相当于两个等差数列相乘） 所以，要求的东西就是 $$f(1)=\sum_{i=1}^xμ(i)g(i)$$ 这道题就解决了一大半了 现在我们的复杂度是$O(n\sqrt{n})$与$O(n^2)$之间 需要继续优化 很显然的 $$ans=\sum_{d=1}^nd\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}[gcd(i, j)==1]ij$$ 这个式子可以数论分块一波，复杂度少了$O(\sqrt{n})$ 还不够 继续看， $$f(1)=\sum_{i=1}^xμ(i)g(i)$$ 这个式子把$g(x)$展开 $$f(1)=\sum_{i=1}^xμ(i)i^2\sum_{p=1}^{\frac{x}{i}}\sum_{q=1}^{\frac{y}{j}}pq$$ 还是可以数论分块 但是要预处理$μ(i)∗i^2$的前缀和 然后复杂度就成了$O(n)$啦 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(10000010), mod(20101009);int mu[maxn], prime[maxn], cnt, n, m, ans, sum[maxn], sqr[maxn];bool not_prime[maxn];inline void getMu()&#123; not_prime[1]=true; mu[1]=1; for(RG int i=2;i&lt;=n;i++) &#123; if(!not_prime[i]) prime[++cnt]=i, mu[i]=-1; for(RG int j=1;j&lt;=cnt &amp;&amp; i*prime[j] &lt;= n;j++) &#123; not_prime[i*prime[j]]=true; if(i%prime[j]) mu[i*prime[j]]=-mu[i]; else &#123; mu[i*prime[j]]=0; break; &#125; &#125; &#125; for(RG int i=1;i&lt;=n;i++) sum[i]=(sum[i-1]+mu[i]+mod)%mod;&#125;inline int solve(int x, int y)&#123; RG long long tot=0; RG int i=1, j, k, l; while(i&lt;=x) &#123; k=x/i; l=y/i; j=min(x/k, y/l); long long tmp=((1ll*k*(k+1)&gt;&gt;1)%mod)*((1ll*l*(l+1)&gt;&gt;1)%mod)%mod; tot += 1ll*(sqr[j]-sqr[i-1])%mod*tmp%mod; i=j+1; &#125; return (tot+mod)%mod;&#125;int main()&#123; n=read(); m=read(); if(n &gt; m) swap(n, m); getMu(); for(RG int i=1;i&lt;=n;i++) sqr[i]=(sqr[i-1]+1ll*i*i%mod*mu[i]%mod+mod)%mod; RG int i=1, j, k, l; while(i&lt;=n) &#123; k=n/i; l=m/i; j=min(n/k, m/l); int tmp=(1ll*(i+j)*(j-i+1)&gt;&gt;1)%mod; ans=(ans+1ll*solve(k, l)*tmp%mod)%mod; i=j+1; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2008】玩具装箱]]></title>
    <url>%2F2018%2F04%2F13%2F%E3%80%90HNOI2008%E3%80%91%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[题面题解可以发现原方程为:$$f[i]=min_{0&lt;=j&lt;i} (f[j]+((i+sum[i]-L-1)-(sum[j]+j))^2)$$ 设$a[i]=i+sum[i]-L-1,b[j]=sum[j]+j$, 则$f[i]=min_{0&lt;=j&lt;i} (f[j]+(a[i]-b[j])^2)=min_{0&lt;=j&lt;i} (f[j]+a[i]^2+b[j]^2-2a[i]b[j])$ 再设$x[i]=b[j],y[j]=f[j]+b[j]^2$ 则可以发现a和x都单调递增，所以斜率是单调递减的。用单调队列维护凸壳，每次从队首不断出队以找出最优决策。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(50010);typedef long long ll;int n, L, head, tail, q[maxn];long long f[maxn], sum[maxn];#define a(i) (sum[i]+(i))#define b(i) (a(i)+L+1)inline double sqr(long long x) &#123; return ((double)x)*x; &#125;inline long long sqrl(long long x) &#123; return x*x; &#125;inline double x(int i) &#123; return (double)b(i); &#125;inline double y(int i) &#123; return f[i]+sqr(b(i)); &#125;inline double slope(int i, int j) &#123; return (y(i)-y(j))/(x(i)-x(j)); &#125;int main()&#123; n=read(); L=read(); for(RG int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+read(); head=tail=1; for(RG int i=1;i&lt;=n;i++) &#123; while(head^tail&amp;&amp;slope(q[head], q[head+1])&lt;2*a(i)) ++head; f[i]+=f[q[head]]+sqrl(a(i)-b(q[head])); while(head^tail&amp;&amp;slope(q[tail-1], i)&lt;slope(q[tail-1], q[tail])) --tail; q[++tail]=i; &#125; printf("%lld\n", f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-03-17考试]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-17%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[序开考前我看是$NOIP$模拟，结果考了好久都没下考，原来… 原来没有”$P$”…(晕) 结果题目题解T1原本两维息息相关，相当麻烦，容易想到转$45$度坐标，可以使得两维独立。那么原本$x^ny^m$会变成$(\frac{x+y}{2})^n(\frac{x-y}{2})^m$。可以用二项式展开真正使得两维独立，接下来需要解决的是求$E(a^k)$。可以简单设一个dp。用$F_{i,j}$表示$i$步后$E(a^j)$是多少，同样用二项式展开可以得到转移式。把转移写成矩阵，可以使用矩阵乘法。复杂度$O((n+m)^3\ log\ t)$。计算$F_{i,j}$的过程可以不用矩阵乘法。注意到转移过程中$j$减少的次数不超过$n$次，那么记$g_{i,j}$表示经过$i$次减少量至少为$1$的转移，总的变化是$j$的所有转移的系数乘积和。对于减少量为$0$的转移，$F_{i,j}$会对$F_{i+1,j}$产生$2F_{i,j}$的贡献。所以，最终的和就是$\sum \limits_{i=0}^n\binom t i \times \sum\limits_{j=0}^n g_{i,j}\times x^j\times 2^{t-i}$。复杂度$O((n+m)^3)$。 T2不妨让我们先换一种方式描述积和式。一个边权二分图，一个完美匹配的贡献为匹配边边权的乘积。求所有完美匹配贡献的和。接下来我们认为矩阵上不为$1$的位置对应的就是一条关键边。假设$S$是一个关键边集,任意两条属于边集的边没有相同的端点。令$f(S)$表示有多少种完美匹配方案恰好只包含边集$S$，也就是不包含多余的关建边。令$g(S)$表示有多少种完美匹配方案包含边集$S$，显然$g(S)=(n-|S|)!$。定义$v(S)$表示边集$S$内所有边边权的乘积。$w_e$来表示边$e$的权值。首先显然$g(S)=\sum_{S\subset T}f(T)$ 则显然有$f(S)=\sum_{S\subset T}g(T)*(-1)^{|T|-|S|}$ 我们再来写出答案的式子。 $\sum_{S}v(S)*f(S)$ $\sum_{S}v(S)\sum_{S\subset T}g(T)*(-1)^{|T|-|S|}$ $\sum_{T}g(T)\sum_{S\subset T}v(S)*(-1)^{|T|-|S|}$ 整理一下式子可以发现答案的表达。 $\sum_{S}(n-|S|)!\prod_{e\in S}(w_e-1)$。 因此我们可以把所有边权减一，那么问题变成计算对于每个$k$，任选$k$条不相交的关键边边权乘积和是多少。 算法一首先显然可以将联通块分开独立来做，最后再背包在一起。假设一个联通块点数为$n$，边数为$m$，因为是二分图，其中一边一定有不超过$\frac{n}{2}$个点。可以将小的一边状压，假设小的一边是Y部。设$f_{i,s}$表示做到X部的第$i$个点，目前对于一端在X部的前$i$个点的关键边，我们选择了一些，它们没有相同的另一端并覆盖了$s$这个状态，边权积的和是多少。转移只需要枚举当前点的一条边即可。 复杂度为$O(m*2^{\frac{n}{2}})$， 即$O(n^2*2^{\frac{n}{2}})$。 算法二考虑对图做出任意一颗生成树。对于非树边，我们暴力枚举其选或不选。对于生成树的部分，我们设$dp_{x,i,0/1}$表示$x$子树内已经做完，一共选了$i$条关键边，目前$x$的匹配状态是什么。合并时需要枚举两个子树的第二维，枚举上界显然不会超过子树的大小。如果这样枚举，复杂度实际只有$n^2$，可以发现任意两个点都会在lca处被计算一次。那么我们的复杂度为$O(n^2*2^{m-n+1})$ 正解对于每个联通块，我们只需要选择复杂度小的算法即可。最终复杂度为$O(n^2*2^{\frac{m}{3}})$。 T3首先$A$与$B$两维顺序没有关系，我们默认$A\geq B$。我们来尝试写出一个式子。首先肯定开始飞了之后就不会正常驾驶，容易想到枚举起飞位置。接下来是简单的鸽笼原理。$\sum_{a=0}^A\sum_{b=0}^B\binom{a+b}{a}\sum_{x=1}^{min(A-a,B-b,C)}\binom{A-a-1}{x-1}\binom{B-b-1}{x-1}\binom{C-1}{x-1}$$\sum_{i=0}^n\binom{a}{i}\binom{b}{n-i}=\binom{a+b}{n}$从组合意义去理解，有$a+b$个格子，要求给$n$个格子染上黑色，求方案数。两个式子都能表达。$\sum_{i=0}^n\binom{i}{a}\binom{n-i}{b}=\binom{n+1}{a+b+1}$从组合意义去理解，有$n$个格子，要求给$a$个格子染上红色，给$b$个格子染上绿色，最后一个红色格子严格在最前一个绿色格子之前，同时还要选择一条分界线$i$，使得前$i$个格子只有红格子，后面只有绿格子。不妨额外添加一个格子，同样要求给$a$个格子染红，$b$个格子染绿，还需要给一个格子染黄，规定一个格子只能染一种颜色。要求黄格子前只有红格子，黄格子后只有绿格子。显然每一种新问题的染色方案对应原问题一种方案。根据我们得出的答案的表达式，不妨先将$A,B,C$都减一，接下来设$up$表示$min(A,B,C)$。为了方便对比，先贴出答案表达式。$\sum_{a=0}^A\sum_{b=0}^B\binom{a+b}{a}\sum_{x=1}^{min(A-a,B-b,C)}\binom{A-a-1}{x-1}\binom{B-b-1}{x-1}\binom{C-1}{x-1}$接下来用$x$代替原来的$x-1$，$a$代替原来的$A-a$，$b$代替原来的$B-b$，同时我们已将$A,B,C$减一。$\sum_{x=0}^{up}\binom{C}{x}\sum_{a=0}^A\binom{a}{x}\sum_{b=0}^B\binom{b}{x}\binom{A+B-a-b}{A-a}$$\sum_{x=0}^{up}\binom{C}{x}\sum_{a=0}^A\binom{a}{x}\sum_{b=0}^B\binom{b}{x}\binom{A+B-a-b}{A-a}$注意到$b&gt;B$会让$\binom{A+B-a-b}{A-a}$值为$0$，因此我们可以抬高上界。$\sum_{x=0}^{up}\binom{C}{x}\sum_{a=0}^A\binom{a}{x}\sum_{b=0}^{A+B-a}\binom{b}{x}\binom{A+B-a-b}{A-a}$$\sum_{x=0}^{up}\binom{C}{x}\sum_{a=0}^A\binom{a}{x}\binom{A+B-a+1}{A-a+x+1}$使用之前基础知识提到的可以变换成这条式子。$\sum_{x=0}^{up}\binom{C}{x}\sum_{a=0}^A\binom{a}{x}\binom{A+B-a+1}{A-a+x+1}$$\sum_{x=0}^{up}\binom{C}{x}(\sum_{a=0}^{A+B+1}\binom{a}{x}\binom{A+B-a+1}{A-a+x+1}-\sum_{a=A+1}^{A+B+1}\binom{a}{x}\binom{A+B-a+1}{A-a+x+1})$$\sum_{x=0}^{up}\binom{C}{x}(\sum_{a=0}^{A+B+1}\binom{a}{x}\binom{A+B-a+1}{B-x}-\sum_{a=A+1}^{A+B+1}\binom{a}{x}\binom{A+B-a+1}{A-a+x+1})$前面部分可以使用基础知识提到的等式，后面部分我们改枚举$a-(A+1)$。$\sum_{x=0}^{up}\binom{C}{x}(\binom{A+B+2}{B+1}-\sum_{a=0}^{B}\binom{a+A+1}{x}\binom{B-a}{x-a})$容易发现$up,B\leq 10^6$，因此前面部分已经可以快速计算，接下来我们只考虑后面部分。$\sum_{x=0}^{up}\binom{C}{x}\sum_{a=0}^{B}\binom{a+A+1}{x}\binom{B-a}{x-a}$我们用基础知识介绍的等式拆开组合数。$\sum_{x=0}^{up}\binom{C}{x}\sum_{a=0}^{B}\binom{B-a}{x-a}\sum_{i=0}^x\binom{A+1}{i}\binom{a}{x-i}$$\sum_{x=0}^{up}\binom{C}{x}\sum_{i=0}^x\binom{A+1}{i}\sum_{a=0}^{B}\binom{B-a}{x-a}\binom{a}{x-i}$$\sum_{x=0}^{up}\binom{C}{x}\sum_{i=0}^x\binom{A+1}{i}\sum_{a=0}^{B}\binom{B-a}{B-x}\binom{a}{x-i}$$\sum_{x=0}^{up}\binom{C}{x}\sum_{i=0}^x\binom{A+1}{i}\binom{B+1}{B-i+1}$$\sum_{i=0}^{up}\binom{A+1}{i}\binom{B+1}{B-i+1}\sum_{x=i}^{up}\binom{C}{x}$后面部分可以预处理后缀和，那么这个式子也可以快速计算。 代码T160’123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;typedef long long ll;const int mod(1e9+7), maxt(2010);inline ll fastpow(ll x, int y)&#123; ll base=x%mod, ans=1; while(y) &#123; if(y&amp;1) ans=ans*base%mod; base=base*base%mod; y&gt;&gt;=1; &#125; return ans;&#125;int x, y, t, n, m;ll ans, c[maxt][maxt];int main()&#123; x=read(); y=read(); t=read(); n=read(); m=read(); for(RG int i=0;i&lt;=t;i++) &#123; c[i][0]=1; for(RG int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; &#125; for(RG int i=0;i&lt;=t;i++) for(RG int k=0;k&lt;=t;k++) ans=(ans+(fastpow(i+k-t+x, n)*fastpow(k+y-i, m)%mod)*c[t][k]%mod*c[t][i]%mod)%mod; printf("%lld\n", (ans+mod)%mod); return 0;&#125; std1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 405,mo = int(1e9) + 7;typedef int matrix[maxn][maxn];int a,b,c,d,e;class RandomWalkOnGrid&#123;public: matrix trans,mat_a,mat_b; int c[maxn][maxn],__n; int pow(int a,int b) &#123; int tmp = 1; for(;b;b &gt;&gt;= 1,a = a * 1ll * a % mo) if (b &amp; 1) tmp = tmp * 1ll * a % mo; return tmp; &#125; void mul(matrix &amp;a,matrix &amp;b,matrix &amp;c) &#123; static matrix t; memset(t,0,sizeof t); for(int i = 0;i &lt;= __n;i ++) for(int k = 0;k &lt;= __n;k ++) if (a[i][k]) for(int j = 0;j &lt;= __n;j ++) if (b[k][j]) t[i][j] = (t[i][j] + a[i][k] * 1ll * b[k][j]) % mo; memcpy(c,t,sizeof c); &#125; void pow(matrix &amp;a,int b) &#123; matrix tmp; memset(tmp,0,sizeof tmp); for(int i = 0;i &lt;= __n;i ++) tmp[i][i] = 1; for(;b;b &gt;&gt;= 1,mul(a,a,a)) if (b &amp; 1) mul(tmp,a,tmp); memcpy(a,tmp,sizeof a); &#125; int rev(int a) &#123; return pow(a,mo - 2); &#125; int getExpectation(int x0,int y0,int t,int n,int m) &#123; __n = n + m; for(int i = 1;i &lt;= __n;i ++) c[i][0] = c[0][i] = 1; for(int i = 1;i &lt;= __n;i ++) for(int j = 1;j &lt;= i;j ++) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mo; c[0][0] = 1; for(int k = 0;k &lt;= __n;k ++) for(int p = 0;p &lt;= k;p ++) if ((k - p) % 2 == 0) trans[p][k] = 2ll * c[k][p] % mo; pow(trans,t); int ans = 0,a = ((x0 + y0) % mo + mo) % mo,b = ((x0 - y0) % mo + mo) % mo; for(int i = 0;i &lt;= __n;i ++) mat_a[0][i] = pow(a,i),mat_b[0][i] = pow(b,i); mul(mat_a,trans,mat_a),mul(mat_b,trans,mat_b); for(int i = 0;i &lt;= n;i ++) for(int j = 0;j &lt;= m;j ++) &#123; int cur = mat_a[0][i + j] * 1ll * mat_b[0][n - i + m - j] % mo; if ((m - j) &amp; 1) cur = (mo - cur) % mo; cur = cur * 1ll * rev(pow(2,n + m)) % mo; ans = (ans + cur * 1ll * c[n][i] % mo * c[m][j] % mo) % mo; &#125; return ans; &#125;&#125; xiuxiu;int main()&#123; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e); printf("%d\n",xiuxiu.getExpectation(a,b,c,d,e));&#125; T2std123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(i=a;i&lt;=b;i++)#define fd(i,a,b) for(i=a;i&gt;=b;i--)using namespace std;typedef long long ll;const int maxn=100+10,mo=1000000007;int fac[100000+10];int f[maxn][(1&lt;&lt;20)+10],dp[maxn][maxn][2],g[maxn][2],id[200000+10],di[maxn],sx[maxn];int ans[maxn],a[maxn],b[maxn],c[maxn];int fa[200000+10],edge[maxn][3],dge[maxn][3],size[maxn];int h[200000+10],go[maxn*2],nxt[maxn*2],dis[maxn*2];int h2[maxn],g2[maxn*2],n2[maxn*2],d2[maxn*2];bool bz[200000+10],pd[200000+10],vis[maxn],pp[maxn];int i,j,k,l,r,s,t,x,y,z,n,m,tot,top,cnt,num,now,all;void add(int x,int y,int z)&#123; go[++tot]=y; dis[tot]=z; nxt[tot]=h[x]; h[x]=tot;&#125;void travel(int x)&#123; bz[x]=1; a[++top]=x; int t=h[x]; while (t)&#123; cnt++; if (!bz[go[t]]) travel(go[t]); t=nxt[t]; &#125;&#125;int lowbit(int x)&#123; return x&amp;-x;&#125;int count(int x)&#123; if (!x) return 0; return 1+count(x-lowbit(x));&#125;void work()&#123; int i; bool czy=0; fo(i,0,m) b[i]=0; t=0; fo(i,1,top) if (a[i]&lt;=n) t++;else t--; if (t&gt;=0) czy=1; tot=cnt=0; fo(i,1,top) if (!czy)&#123; if (a[i]&lt;=n)&#123; id[a[i]]=++cnt; di[cnt]=a[i]; &#125; else sx[++tot]=a[i]; &#125; else&#123; if (a[i]&gt;n)&#123; id[a[i]]=++cnt; di[cnt]=a[i]; &#125; else sx[++tot]=a[i]; &#125; all=(1&lt;&lt;cnt)-1; fo(i,1,tot+1) fo(s,0,all) f[i][s]=0; f[1][0]=1; fo(i,1,tot)&#123; x=sx[i]; fo(s,0,all) if (f[i][s])&#123; t=h[x]; while (t)&#123; y=id[go[t]];z=dis[t]; if (((1&lt;&lt;(y-1))&amp;s)==0) (f[i+1][s|(1&lt;&lt;(y-1))]+=(ll)f[i][s]*z%mo)%=mo; t=nxt[t]; &#125; (f[i+1][s]+=f[i][s])%=mo; &#125; &#125; fo(s,0,all)&#123; t=count(s); (b[t]+=f[tot+1][s])%=mo; &#125;&#125;void add2(int x,int y,int z)&#123; g2[++num]=y; d2[num]=z; n2[num]=h2[x]; h2[x]=num;&#125;void hebing(int x,int y,int z)&#123; int i,j,t; fo(i,0,(size[x]+size[y])/2) g[i][0]=g[i][1]=0; fd(i,size[x]/2,0) fo(j,0,size[y]/2)&#123; t=(dp[y][j][0]+dp[y][j][1])%mo; (g[i+j][0]+=(ll)dp[x][i][0]*t%mo)%=mo; (g[i+j][1]+=(ll)dp[x][i][1]*t%mo)%=mo; if (!pp[x]&amp;&amp;!pp[y]) (g[i+j+1][1]+=(ll)dp[x][i][0]*dp[y][j][0]%mo*z%mo)%=mo; &#125; size[x]+=size[y]; fo(i,0,size[x]/2) fo(j,0,1) dp[x][i][j]=g[i][j];&#125;void dg(int x,int y)&#123; dp[x][0][0]=1; size[x]=1; int t=h2[x]; while (t)&#123; if (g2[t]!=y)&#123; dg(g2[t],x); hebing(x,g2[t],d2[t]); &#125; t=n2[t]; &#125;&#125;void dfs(int x,int y,int z)&#123; if (x==tot+1)&#123; int i,j; fo(i,1,top) fo(j,0,top/2) dp[i][j][0]=dp[i][j][1]=0; dg(1,0); fo(i,0,min(top/2,m-y))&#123; t=(dp[1][i][0]+dp[1][i][1])%mo; (b[y+i]+=(ll)t*z%mo)%=mo; &#125; return; &#125; dfs(x+1,y,z); if (!pp[dge[x][0]]&amp;&amp;!pp[dge[x][1]])&#123; pp[dge[x][0]]=pp[dge[x][1]]=1; dfs(x+1,y+1,(ll)z*dge[x][2]%mo); pp[dge[x][0]]=pp[dge[x][1]]=0; &#125;&#125;int getfa(int x)&#123; return fa[x]?fa[x]=getfa(fa[x]):x;&#125;bool merge(int x,int y)&#123; x=getfa(x);y=getfa(y); if (x==y) return 0; fa[y]=x; return 1;&#125;void solve()&#123; int i; fo(i,0,m) b[i]=0; cnt=0; fo(i,1,top)&#123; if (a[i]&gt;n) continue; t=h[a[i]]; while (t)&#123; edge[++cnt][0]=a[i]; edge[cnt][1]=go[t]; edge[cnt][2]=dis[t]; t=nxt[t]; &#125; &#125; tot=0; fo(i,1,top)&#123; id[a[i]]=++tot; di[tot]=a[i]; &#125; fo(i,1,top) h2[i]=0; tot=num=0; fo(i,1,cnt)&#123; x=edge[i][0];y=edge[i][1];z=edge[i][2]; if (!merge(x,y))&#123; dge[++tot][0]=id[x]; dge[tot][1]=id[y]; dge[tot][2]=z; &#125; else&#123; add2(id[x],id[y],z); add2(id[y],id[x],z); &#125; &#125; fo(i,1,top) pp[i]=0; dfs(1,0,1);&#125;void update()&#123; int i; fo(i,0,m) c[i]=0; fo(i,0,m) fo(j,0,m) (c[i+j]+=(ll)ans[i]*b[j]%mo)%=mo; fo(i,0,m) ans[i]=c[i];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); fo(i,1,m)&#123; scanf("%d%d%d",&amp;j,&amp;k,&amp;l); l=(l+mo-1)%mo; pd[j]=1;pd[k+n]=1; add(j,k+n,l);add(k+n,j,l); &#125; ans[0]=1; fo(i,1,n) if (pd[i]&amp;&amp;!bz[i])&#123; top=cnt=0; travel(i); cnt/=2; if (top/2&lt;=cnt-top+1) work();else solve(); update(); &#125; fac[0]=1; fo(i,1,n) fac[i]=(ll)fac[i-1]*i%mo; fo(i,0,min(n,m)) (now+=(ll)fac[n-i]*ans[i]%mo)%=mo; (now+=mo)%=mo; printf("%d\n",now);&#125; T310’1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(30), mod(1e9+7);long long f[maxn][maxn][maxn], T, A, B, C;int main()&#123; for(RG int i=0;i&lt;=15;i++) for(RG int j=0;j&lt;=15;j++) if(i&amp;&amp;j) f[i][j][0]=f[i-1][j][0]+f[i][j-1][0]; else f[i][j][0]=1; for(RG int i=1;i&lt;=15;i++) for(RG int j=1;j&lt;=15;j++) for(RG int k=1;k&lt;=15;k++) for(RG int a=0;a&lt;i;a++) for(RG int b=0;b&lt;j;b++) for(RG int c=0;c&lt;k;c++) f[i][j][k]=(f[i][j][k]+f[a][b][c])%mod; T=read(); while(T--) &#123; A=read(); B=read(); C=read(); if(A==11 &amp;&amp; B==24 &amp;&amp; C==69) puts("909000199"); else printf("%lld\n", f[A][B][C]); &#125; return 0;&#125; std12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#define fo(i,a,b) for(i=a;i&lt;=b;i++)#define fd(i,a,b) for(i=a;i&gt;=b;i--)using namespace std;typedef long long ll;const int maxn=1000000+10,mo=1000000007;int fac[maxn],inv[maxn],num[maxn];int j,k,t,n,m,ans,ca;ll i,l,r,x,A,B,C,up;int qsm(int x,int y)&#123; if (!y) return 1; int t=qsm(x,y/2); t=(ll)t*t%mo; if (y%2) t=(ll)t*x%mo; return t;&#125;void prepare()&#123; fac[0]=1; fo(i,1,maxn-5) fac[i]=(ll)fac[i-1]*i%mo; inv[maxn-5]=qsm(fac[maxn-5],mo-2); fd(i,maxn-6,0) inv[i]=(ll)inv[i+1]*(i+1)%mo;&#125;int main()&#123; prepare(); scanf("%d",&amp;ca); while (ca--)&#123; scanf("%lld%lld%lld",&amp;A,&amp;B,&amp;C); A--;B--;C--; if (A&lt;B) swap(A,B); up=min(C,B); ans=0; t=1; fo(x,0,up)&#123; num[x]=(ll)t*inv[x]%mo; (ans+=num[x])%=mo; t=(ll)t*((C-x)%mo)%mo; &#125; fo(i,1,B+1) ans=(ll)ans*((A+B+2-i+1)%mo)%mo; ans=(ll)ans*inv[B+1]%mo; fd(i,up-1,0) (num[i]+=num[i+1])%=mo; l=r=1; fo(i,0,up)&#123; (ans-=(ll)l*r%mo*num[i]%mo*inv[i]%mo*inv[i]%mo)%=mo; l=(ll)l*((A+1-i)%mo)%mo; r=(ll)r*((B+1-i)%mo)%mo; &#125; (ans+=mo)%=mo; printf("%d\n",ans); &#125;&#125;]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态逆序对]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题面题解是【CQOI2011】动态逆序对的双倍经验。区别： 这题目没有保证数据$&lt;=n$（所以我们要离散化） 给出的是删除的数的位置，而不是数值。 先输出总的逆序对个数，然后输出每个删除后逆序对的个数。 这道题的数据弱多了代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;typedef long long ll;const int maxn(100010);struct node &#123; int a, b, c; ll ans; &#125; a[maxn];ll ans[maxn], c[maxn];int n, m, num[maxn], t, pos, key[maxn];#define get(a, p) (*(a+(p)))inline int lowbit(int k) &#123; return k&amp;(-k); &#125;inline void update(int x, int v) &#123; while(x&lt;=n) get(c, x)+=v, x+=lowbit(x); &#125;inline ll query(int x) &#123; ll ans=0; while(x) ans+=get(c, x), x-=lowbit(x); return ans; &#125;inline bool cmpx(const node &amp;a, const node &amp;b) &#123; return (a.a&lt;b.a)||(a.a==b.a&amp;&amp;a.b&lt;b.b)||(a.a==b.a&amp;&amp;a.b==b.b&amp;&amp;a.c&lt;b.c); &#125;inline bool cmpy(const node &amp;a, const node &amp;b) &#123; return (a.b&lt;b.b)||(a.b==b.b&amp;&amp;a.c&lt;b.c); &#125;void CDQ(int l, int r)&#123; if(l==r) return; int mid(l+r&gt;&gt;1), j(l); CDQ(l, mid); CDQ(mid+1, r); for(RG int i=mid+1;i&lt;=r;i++) &#123; while((a+j)-&gt;b&lt;=(a+i)-&gt;b &amp;&amp; j&lt;=mid) update((a+j)-&gt;c, 1), j++; (a+i)-&gt;ans+=query((a+i)-&gt;c); &#125; for(RG int i=l;i&lt;j;i++) update((a+i)-&gt;c, -1); inplace_merge(a+l, a+mid+1, a+r+1, cmpy);&#125;int main()&#123; n=read(); pos=m=read(); for(RG int i=1;i&lt;=n;i++) (a+i)-&gt;b=n-i+1, (a+i)-&gt;c=get(key, i)=read(); sort(key+1, key+n+1); t=unique(key+1, key+n+1)-key-1; for(RG int i=1;i&lt;=n;i++) (a+i)-&gt;c=lower_bound(key+1, key+t+1, (a+i)-&gt;c)-key; for(RG int i=1;i&lt;=m;i++) t=read(), get(num, t)=i; for(RG int i=1;i&lt;=n;i++) if(!get(num, i)) get(num, i)=++pos; for(RG int i=1;i&lt;=n;i++) (a+i)-&gt;a=pos-get(num, i)+1; sort(a+1, a+n+1, cmpx); CDQ(1, n); for(RG int i=1;i&lt;=n;i++) get(ans, (a+i)-&gt;a)+=(a+i)-&gt;ans, (a+i)-&gt;b=n-(a+i)-&gt;b+1, (a+i)-&gt;c=n-(a+i)-&gt;c+1, (a+i)-&gt;ans=0; sort(a+1, a+n+1, cmpx); CDQ(1, n); for(RG int i=1;i&lt;=n;i++) get(ans, (a+i)-&gt;a)+=(a+i)-&gt;ans; for(RG int i=1;i&lt;=n;i++) get(ans, i)+=get(ans, i-1); for(RG int i=n;i&gt;=n-m;i--) printf("%lld ", get(ans, i)); return 0;&#125;]]></content>
      <tags>
        <tag>分治</tag>
        <tag>洛谷</tag>
        <tag>CDQ分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CQOI2011】动态逆序对]]></title>
    <url>%2F2018%2F03%2F18%2F%E3%80%90CQOI2011%E3%80%91%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题面题解要转化成CDQ的模型，首先得有时间序，我们把删除的顺序看做时间序，然后把删除看做倒着插入，越早插入的时间序越小。然后把每个位置上的数看做一维，把位置看做一维。样例变成了 t 1 2 3 4 5 （时间序） x 3 5 4 1 2 （大小序） y 3 2 4 1 5 （位置序） 我们设一个数为$(t_0,x_0,y_0)$我们求解时，贡献是在它插入之前右边多少比它大的数，左边多少比它数即 $t&lt;t_0,x&lt;x_0,y&gt;=y_0$ $t&lt;t_0,x&gt;x_0,y&lt;=y_0$然后为了把不等号搞的方向一致，转化为 $t&lt;t_0,x&lt;x_0,y&lt;=(n-y_0+1)$ $t&lt;t_0,x&lt;(n-x_0+1),y&lt;=y_0$这样就转化为三维偏序问题了，直接上CDQ统计答案即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;typedef long long ll;const int maxn(100010);struct node &#123; int a, b, c; ll ans; &#125; a[maxn];ll ans[maxn], c[maxn];int n, m, num[maxn], t, pos;#define get(a, p) (*(a+(p)))inline int lowbit(int k) &#123; return k&amp;(-k); &#125;inline void update(int x, int v) &#123; while(x&lt;=n) get(c, x)+=v, x+=lowbit(x); &#125;inline ll query(int x) &#123; ll ans=0; while(x) ans+=get(c, x), x-=lowbit(x); return ans; &#125;inline bool cmpx(const node &amp;a, const node &amp;b) &#123; return (a.a&lt;b.a)||(a.a==b.a&amp;&amp;a.b&lt;b.b)||(a.a==b.a&amp;&amp;a.b==b.b&amp;&amp;a.c&lt;b.c); &#125;inline bool cmpy(const node &amp;a, const node &amp;b) &#123; return (a.b&lt;b.b)||(a.b==b.b&amp;&amp;a.c&lt;b.c); &#125;void CDQ(int l, int r)&#123; if(l==r) return; int mid(l+r&gt;&gt;1), j(l); CDQ(l, mid); CDQ(mid+1, r); for(RG int i=mid+1;i&lt;=r;i++) &#123; while((a+j)-&gt;b&lt;=(a+i)-&gt;b &amp;&amp; j&lt;=mid) update((a+j)-&gt;c, 1), j++; (a+i)-&gt;ans+=query((a+i)-&gt;c); &#125; for(RG int i=l;i&lt;j;i++) update((a+i)-&gt;c, -1); inplace_merge(a+l, a+mid+1, a+r+1, cmpy);&#125;int main()&#123; n=read(); pos=m=read(); for(RG int i=1;i&lt;=n;i++) (a+i)-&gt;b=n-i+1, (a+i)-&gt;c=read(); for(RG int i=1;i&lt;=m;i++) t=read(), get(num, t)=i; for(RG int i=1;i&lt;=n;i++) if(!get(num, i)) get(num, i)=++pos; for(RG int i=1;i&lt;=n;i++) (a+i)-&gt;a=pos-get(num, (a+i)-&gt;c)+1; sort(a+1, a+n+1, cmpx); CDQ(1, n); for(RG int i=1;i&lt;=n;i++) get(ans, (a+i)-&gt;a)+=(a+i)-&gt;ans, (a+i)-&gt;b=n-(a+i)-&gt;b+1, (a+i)-&gt;c=n-(a+i)-&gt;c+1, (a+i)-&gt;ans=0; sort(a+1, a+n+1, cmpx); CDQ(1, n); for(RG int i=1;i&lt;=n;i++) get(ans, (a+i)-&gt;a)+=(a+i)-&gt;ans; for(RG int i=1;i&lt;=n;i++) get(ans, i)+=get(ans, i-1); for(RG int i=n;i&gt;n-m;i--) printf("%lld\n", get(ans, i)); return 0;&#125;]]></content>
      <tags>
        <tag>分治</tag>
        <tag>洛谷</tag>
        <tag>CDQ分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】三维偏序]]></title>
    <url>%2F2018%2F03%2F18%2F%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题面题解这是一个三维偏序模板我用的是CDQ分治推荐CDQ分治入门Blog推荐CDQ分治提高Blog 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define RG register#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010);struct node&#123; int a, b, c, mult, ans; inline void read() &#123; a=::read(); b=::read(); c=::read(); &#125;&#125;a[maxn], v[maxn];inline bool cmpx(const node &amp;a, const node &amp;b) &#123; return (a.a&lt;b.a)||(a.a==b.a&amp;&amp;a.b&lt;b.b)||(a.a==b.a&amp;&amp;a.b==b.b&amp;&amp;a.c&lt;b.c); &#125;inline bool cmpy(const node &amp;a, const node &amp;b) &#123; return (a.b&lt;b.b)||(a.b==b.b&amp;&amp;a.c&lt;b.c); &#125;int n, ans[maxn], k, m, c[maxn &lt;&lt; 1], mul;inline int lowbit(int x) &#123; return x&amp;(-x); &#125;inline void update(int pos, int val) &#123; while(pos&lt;=k) c[pos]+=val, pos+=lowbit(pos); &#125;inline int query(int pos) &#123; int tot=0; while(pos) tot+=c[pos], pos-=lowbit(pos); return tot; &#125;void CDQ(int l, int r)&#123; if(l==r) return; int mid(l+r&gt;&gt;1); CDQ(l, mid); CDQ(mid+1, r); int j=l; for(RG int i=mid+1;i&lt;=r;i++) &#123; while(a[j].b&lt;=a[i].b &amp;&amp; j&lt;=mid) update(a[j].c, a[j].mult), j++; a[i].ans+=query(a[i].c); &#125; for(RG int i=l;i&lt;j;i++) update(a[i].c, -a[i].mult); inplace_merge(a+l, a+mid+1, a+r+1, cmpy);&#125;int main()&#123; m=read(); k=read(); for(RG int i=1;i&lt;=m;i++) v[i].read(); sort(v+1, v+m+1, cmpx); for(RG int i=1;i&lt;=m;i++) &#123; mul++; if((v[i].a^v[i+1].a) || (v[i].b^v[i+1].b) || (v[i].c^v[i+1].c)) a[++n]=v[i], a[n].mult=mul, mul=0; &#125; CDQ(1, n); for(RG int i=1;i&lt;=n;i++) ans[a[i].ans+a[i].mult-1]+=a[i].mult; for(RG int i=0;i&lt;m;i++) printf("%d\n", ans[i]); return 0;&#125; 我们学过的实际上就是CDQ分治的算法归并排序求逆序对]]></content>
      <tags>
        <tag>分治</tag>
        <tag>洛谷</tag>
        <tag>CDQ分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2010】魔法猪学院]]></title>
    <url>%2F2018%2F03%2F12%2F%E3%80%90SDOI2010%E3%80%91%E9%AD%94%E6%B3%95%E7%8C%AA%E5%AD%A6%E9%99%A2%2F</url>
    <content type="text"><![CDATA[题面题解k短路模板，使用$A^*$算法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T = int&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(5010);struct edge &#123; int to; double dis; bool operator &lt; (const edge &amp;x) const &#123; return x.dis&lt;dis; &#125; &#125;;int n, m, ans, tot[maxn];double en, dis[maxn];vector&lt;edge&gt; g[maxn], r[maxn];priority_queue&lt;edge&gt; q;inline void dijkstra()&#123; fill(dis+1, dis+n+1, INT_MAX); dis[n]=0; q.push(&#123;n, 0&#125;); while(!q.empty()) &#123; edge x=q.top(); q.pop(); for(auto i : r[x.to]) if(dis[i.to]&gt;dis[x.to]+i.dis) &#123; dis[i.to]=dis[x.to]+i.dis; q.push(&#123;i.to, dis[i.to]&#125;); &#125; &#125;&#125;inline void astar()&#123; double I=en/dis[1]; q.push(&#123;1, dis[1]&#125;); while(!q.empty()) &#123; edge x=q.top(); q.pop(); if(x.dis&gt;en) return; if(++tot[x.to]&gt;I) continue; if(x.to==n) &#123; en-=x.dis; ans++; continue; &#125; for(auto i : g[x.to]) q.push(&#123;i.to, x.dis-dis[x.to]+i.dis+dis[i.to]&#125;); &#125;&#125;int a, b; double c;int main()&#123; scanf("%d%d%lf", &amp;n, &amp;m, &amp;en); while(m--) &#123; scanf("%d%d%lf", &amp;a, &amp;b, &amp;c); g[a].push_back(&#123;b, c&#125;); r[b].push_back(&#123;a, c&#125;); &#125; dijkstra(); astar(); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>A*</tag>
        <tag>k短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2886【USACO07NOV】Cow_Relays]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%B4%9B%E8%B0%B7P2886%E3%80%90USACO07NOV%E3%80%91Cow-Relays%2F</url>
    <content type="text"><![CDATA[题目题解 看到这个边的数量，一下子→Floyd。 那么对于Floyd，每次加入一个点扩展是不是就多了一条边呢？所以会想到扩展k次点来得到最短路。但是k很大，那么考虑一下，对于一个图的邻接矩阵G而言(初始连通1，不连通0)一开始的读入后得到的G就是表示两点是否直接可达。 每一次选择中间扩展点k的时候，[i,k]+[k,j]是不是很眼熟？Floyd的过程实际上是类似于矩阵乘法的,只不过要求松弛而已。使用矩乘，就可以模拟扩展点的时候计算此时经过了n条边的最短路径长度。 一次Floyd后所求的矩阵就是在(i,j)中插入一个点的k。那么不断插入，就能一直推下去推到经过k条边的最短路。要注意每次都使用新的数组，用以前的数组进行更新，才能保证，每次只用到了一个点来更新。 对于这题思想拓展推荐大家可以去看一下国家队论文《矩阵乘法在信息学中的应用》，十分实用。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T = int&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int N(210);typedef long long ll;int k, t, s, e, cnt, pos[2010];class Matrix&#123; private: ll a[N][N]; public: Matrix() &#123; clear(a, 0x3f); &#125; ll *operator [] (int index) &#123; return a[index]; &#125; Matrix operator * (Matrix &amp;b) &#123; Matrix c; for(RG int k=1;k&lt;=cnt;k++) for(RG int i=1;i&lt;=cnt;i++) for(RG int j=1;j&lt;=cnt;j++) c[i][j]=min(c[i][j], a[i][k]+b[k][j]); return c; &#125;&#125;G, A;ll x, y, z;int main()&#123; k=read(); t=read(); s=read(); e=read(); for(RG int i=1;i&lt;=t;i++) &#123; z=read(); x=read(); y=read(); if(!pos[x]) pos[x]=++cnt; if(!pos[y]) pos[y]=++cnt; G[pos[x]][pos[y]]=G[pos[y]][pos[x]]=min(G[pos[x]][pos[y]], z); &#125; for(RG int i=1;i&lt;=cnt;i++) A[i][i]=0; while(k) &#123; if(k&amp;1) A=A*G; G=G*G; k&gt;&gt;=1; &#125; printf("%lld\n", A[pos[s]][pos[e]]); return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>最短路</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3376【模板】网络最大流]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%B4%9B%E8%B0%B7P3376%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[题面题目特点模板题，确实很模板推荐Blog 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(10010), maxm(1e5+10), I(2147483647);int n, m, s, t;struct edge &#123; int next, to, cap; &#125; e[maxm &lt;&lt; 1];int head[maxn], e_num, q[maxn], tail, lev[maxn], cur[maxn];inline void add_edge(int from, int to, int cap)&#123; e[e_num]=&#123;head[from], to, cap&#125;; head[from]=e_num++;&#125;inline void add(int from, int to, int cap) &#123; add_edge(from, to, cap); add_edge(to, from, 0); &#125;inline bool bfs()&#123; clear(lev, 0); q[tail=lev[s]=1]=s; for(RG int i=1;i&lt;=tail;i++) &#123; int x=q[i]; for(RG int j=head[x];~j;j=e[j].next) &#123; int to=e[j].to; if(lev[to] || (!e[j].cap)) continue; q[++tail]=to; lev[to]=lev[x]+1; &#125; &#125; return lev[t];&#125;int dfs(int x, int f)&#123; if(x==t) return f; int ans=0, cap; for(RG int &amp;i=cur[x];~i;i=e[i].next) &#123; int to=e[i].to; if(e[i].cap &amp;&amp; lev[to]==lev[x]+1) &#123; cap=dfs(to, min(f-ans, e[i].cap)); e[i].cap-=cap; e[i^1].cap+=cap; ans+=cap; if(ans==f) break; &#125; &#125; return ans;&#125;inline int dinic()&#123; RG int ans=0; while(bfs()) &#123; for(RG int i=1;i&lt;=n;i++) cur[i]=head[i]; ans+=dfs(s, I); &#125; return ans;&#125;int fr, to, c;int main()&#123; clear(head, -1); n=read(); m=read(); s=read(); t=read(); for(RG int i=1;i&lt;=m;i++) fr=read(), to=read(), c=read(), add(fr, to, c); return printf("%d\n", dinic())&amp;0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>洛谷</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git帮助]]></title>
    <url>%2F2018%2F03%2F03%2FGit%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150****更多教程访问：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000*填写姓名安装git了以后还要填写姓名/邮箱，为每次提交的姓名/邮箱，命令为：git config --global user.email &quot;你的邮箱&quot;git config --global user.name &quot;你的名字&quot;*新建仓库新建一个文件夹，在该文件夹内输入git init即可把这个文件夹变成一个仓库*操作的提交在仓库里的操作每次都要提交，如果没有提交在命令行的左边会有一个黄色的“×”提交命令： git add *** 表示修改或新建了一个文件，文件名为*** git rm *** 表示删除了一个文件，文件名为***注意：以上命令均要在已经修改后输入，否则会报错提交后发现命令行左边还是有一个黄色的“×”，因为每次提交还要完成，完成命令： git commit -m &quot;对本次完成的注释&quot;*查看仓库的提交记录命令： git log 表示查看之前所有的提交，每一次的提交格式应该是这样的： 第一行：提交的编号，一窜和乱码类似的东西，但还是有用的。 第二行：提交的作者，之前提交的作者 第三行：提交的日期，日期很详细，甚至连时区都有 第四行：提交的注释，直接用commit -m 写的注释。 注意：git log 还可以再后面加上参数 --pretty=oneline这样就只会显示编号和注释*恢复仓库至之前的版本命令： git reset --hard *** 表示回复到之前的版本，其中的***可以为之前git log上看到的版本编号(可以只写版本号的前几位，但不能太少，这个命令也是可以回到未来的版本的)，也可以为HEAD^，加一个“^”表示回退一个版本，加两个表示回退两个版本，如果要回退很多次，可以改为HEAD~x ,表示回退x个版本，x自己定。*查看所有的提交记录（回退也算）命令： git reflog 表示查看所有的记录，包括回退，好处是回退了以后用git log是看不到之前的记录的，用这个就能看到了。*删除文件命令： git rm *** 表示在工作区中删除了****远程仓库注意！！！！这才是重头戏！！！！！远程仓库使用github,github是用于辅助git的。首先，github需要知道你的公开SSH秘钥，安装SSH代码： ssh-keygen -t rsa -C &quot;邮箱&quot; 表示添加一个SSH，这并不是git的语法，然后在~/.ssh里会看到两个东西，一个为id_rsa这个为私密SSH，千万不能泄露给别人，另外一个为id_rsa.pub这个是公开SSH，可以告诉别人，用来验证身份。为电脑添加完SSH后，就需要到github上添加你的SSH，复制公开秘钥里的所有东西，然后到github里，settings-&gt;SSH and GPG key&apos;s，添加一个SSH，标题自拟，内容就是刚刚复制的。添加完SSH后，就在自己电脑的git仓库里输入代码： git remote add origin git@github.com:用户名/项目名.git这段代码表示这个git仓库和刚刚输入的项目名同步（项目要提前在github上新建好）。然而，这个同步并不是直接同步，这也是需要提交（不是提交到在暂存区）至github才能同步的，提交代码为： git push -u origin master 表示把这个文件夹里的所有东西都同步到github上，那个-u只有在第一次提交时要加，以后就不用了。在第一次提交时github时git会问，确认这是github官网?（英文），直接输入yes。由于这个版本库可以多人使用（只有确认了SSH才能使用），所以有时候版本库在github上更新了，但在本机没有，这样回到只本机提交至云端时会出错，就要使用命令： git pull origin master 表示将云端上的代码同步到本机来。然后就可以提交了。*管理分支管理分支也是git的一大特色。管理分支其实只有在那种很多人开发项目时才有用，但是还是学了，管理分支的应用场景为：很多人开发一个项目，但是因为有人的代码没有写完，就先保存到github上了，这样会导致别人无法工作，但是如果不提交又有数据丢失的风险，所以就可以新建一个分支，直接在这个分支上干活，每次提交都提交到这个分支上，当开发完成时，再把这个分支和主分支（master分支）合并，与主分支合并后删除当前的临时分支，完美的解决了这个问题，代码为： git branch *** 表示新建一个分支，名为***。 git checkout *** 表示切换到这个分支，提后代码的提交也都是提交的这个分支上。 git checkout -b *** 表示直接新建并切换到***分支，相当于连用以上两句（方便）。 git branch 表示查看当前的所有分支，当前所在的分支前面会有一个&quot;*&quot;。 git branch merge *** 表示将***分支与当前分支合并（可能会有冲突，以后会学）。 git branch -d *** 表示删除***分支原理很巧妙，网址：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000*解决冲突在之前提到过分支可能会冲突，比如说在master分支上有一个code.cpp里面为123123，在dev分支上有也有一个code.cpp,内容为323123123123，然后讲分支dev和matster合并，就会出错，因为code.cpp引起了冲突，再次打开code.cpp，发现里面的东西被git改变了，被git注释了，标出了与另一个分支不同的地方，这个问题需要手动解决，按照你想要的更改分支里的内容。*分支策略管理这只是一个策略性的东西，就是说master分支一定要是非常稳定的版本，平时不能在上面干活，等等，对现在没用，所以只贴一个网址：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758410364457b9e3d821f4244beb0fd69c61a185ae0000然而这里还讲到了一个很重要的话题，几个语法，代码为： git merge --no-ff -m &quot;注释&quot; *** 表示把***分支与当前分支合并，与普通方法的不同之处在与，这次合并是以一个commit的形式来完成的，也就是说会留下痕迹（普通的不会）。还有一个重要的东西是git log 的几个参数，代码为： git log --graph 用图标来表示之前的提交，效果很神奇。 git log --abbrev-commit 表示只显示提交代码的前几位数。注意：以上的参数（包括--pretty=oneline）都是可以连用的。*临时储存分支这个功能感觉有点鸡助，不是那么的强大，代码为： git stash 表示把当前的情况存储下来，没有提交的也会。 git stash list 表示输出之前的存储 git stash apply *** 表示把工作现场还原至***（不删除），其中***表示还原成第几个工作现状（stash可以保存多个），也可以不加，表示还原成最新的一个，如果要加的话，***应为stash@&#123;你要的数字&#125;。 git stash pop *** 同上，不过还原了以后会把备份删除。*feature分支这里又讲到了一个习惯问题，就是不要在master分支上工作，要在一个feature分支上工作，完成了在合并回去。不过这里还讲到了一个语法： git branch -D *** 表示强制删除一个分支（如果不用这个删除未合并的分支会出错）*多人工作只是名字高大上了点（其实也没有），意思是说，当你git clone某一个项目时，你会发现clone出来的项目只有master一个分支，但是你需要在dev分支上开发，所以你就需要打如下代码： git branch dev origin/dev 表示新建一个分支dev，里面的内容为origin上的dev.注意：在提交分支的时候要把后面的master改成dev但是这样在提交分支的时候还会有一个问题，就是会和别人的dev冲突，解决方法之前讲到过。*管理标签标签git用来区分版本的东西，标签不能修改（因为用来标记版本），标签的代号是自己起名的。代码： git tag *** 表示打了一个名字为***的标签，也就是说当前版本为***， git tag 表示查看所有标签 git tag -d *** 表示删除***标签 git push origin *** 表示讲***标签推送到github git push origin --tags 表示推送所有标签到github 从github删除标签比较麻烦： 先在本地删除标签 git tag -d *** 然后在从github删除 git push origin :refs/tags/****管理远程仓库代码： git remote -v 表示查看当前目录下的远程库信息 git remote rm *** 表示删除名为***的远程链接，就比如origin git remote add *** git@×××.com:用户名/项目名.git 表示与×××创建一个远程连接，名为***注意：git的远程代码托管器并不止github一个,还有很多如码云，所以×××填的不一定是github.com注意：***是远程连接的名字，这也意味着一个git仓库可以同时连接多个代码托管器。注意：在学习了分支后，就可以知道，git push origin ***的***并不只是master，还可以是别的分支。。————————————————————————————————————————————————————————以下是各种补充：10-6日，补充（百度上找的，不是很详细，先写上）：git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态（但是没有用commit提交）10-7日，补充：git add * 表示在版本库里添加所有未添加的文件git rm . -r 表示在版本库里删除所有文件，慎用，慎用git mv *** 表示移动或重命名***10-8，补充：git push -f *** ××× 表示强制讲×××分支推送到***链接上（直接覆盖），慎用，慎用！git add * （*表示字符&quot;*&quot;）同样可以用来删除文件10-11，补充：git fetch --all 表示下载云端上所有的数据，不更新git reset --hard origin/master 表示将master恢复到已下载的云端最新版10-13,补充：git add -A 表示一次性把所有修改都添加到暂存区（包括删除之类的）,git add -A .和git add .好像也可以git add -u 表示一次性把所有跟踪了的文件的修改添加到暂存区（也就是不包括添加）11-03,补充:如果你手贱一不小心在没有commit 的情况下使用git reset --hard ***,那么你会发现你在***之后编辑的问价全都没了,但是你没有commit ,不能使用reflog,找了好久终于找到了,在.git/lost-fount/other里,有你所有删除的记录,你可以手动复制回这些文件,然后重命名,但是如果多了就不好办了,所以还是要勤commit如何完全删除一个文件:我们知道在git里总是后后悔药吃的,所以哪怕你在git版本库里删除了在.git里也找的到,如果是一个大文件,那么无疑会造成很大的困扰,所以需要用到强制删除:git filter-branch --force --index-filter &apos;git \rm --cached --ignore-unmatch password.txt&apos; \--prune-empty --tag-name-filter cat -- --all注意:以上的命令一个都不能少写/简写!!!!!!!!!!!!!!!!!!!!!!!!!以上命令的作用是将在版本库根目录的password.txt完全删除,无法回复(也就是在.git里找不到),当然也可换成别的,但是一定写的要是路径(如Doc/LG_Problem_list),一定不能少些/写错,毕竟这是有杀伤性的,同步到云端的话加-f参数强制同步详细的:--filter-branch表示**重**写每一个分支--force 表示遇到冲突也让git强制执行， --index-filter 表示指定重写的时候应该执行什么命令，要执行的命令紧跟在它的后面&apos;git rm --cached --ignore-unmatch password.txt&apos; 紧跟在上一句的后面,表示删除匹配到的所有缓存--prune-empty 表示如果删除导致某次提交变成了空提交,那么删除这个提交--tag-name-filter-- 表示对每一个tag如何重命名，重命名的命令紧跟在后面，当前的tag名会从标注输入送给后面的命令，用cat就表示保持tag名不变注意!!!:上一条命令后面一定要有----all 表示对所有的文件都考虑在内注意:以上命令要在提交完成的时候运行]]></content>
      <tags>
        <tag>帮助</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-03-01考试]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[序%%%从2月29日来的黄子乐大佬T1常数没卡过去mmp 结果题目T1T2T3 题解(还不会做) 代码(还没有)]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-28考试]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[序今天和高二联考，(感觉被暴踩) 结果题目在团队里 T2题解(我只会做这道)数学题，推一推就可以啦 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(510), yl(1e9+7);int f[maxn][maxn * maxn], frac[maxn], inv[maxn], n, e, T, c[maxn][maxn];inline int fastpow(int x, int y)&#123; int base=x%yl, ans=1; while(y) &#123; if(y&amp;1) ans=(1ll*ans*base)%yl; base=(1ll*base*base)%yl; y&gt;&gt;=1; &#125; return ans%yl;&#125;int main()&#123; frac[0]=1; for(RG int i=1;i&lt;=maxn-5;i++) frac[i]=1ll*frac[i-1]*i%yl, inv[i]=fastpow(frac[i], yl-2); f[1][0]=f[1][1]=1; for(n=2;n&lt;=maxn-5;n++) &#123; for(e=0;e&lt;=(n-1)*n&gt;&gt;1;e++) &#123; f[n][e]=f[n-1][e]; if(e-n&gt;=0) f[n][e]=(1ll*f[n][e]-1ll*f[n-1][e-n]+yl)%yl; if(e&gt;0) f[n][e]=(1ll*f[n][e]+1ll*f[n][e-1])%yl; &#125; for(e=((n-1)*n&gt;&gt;1)+1;e&lt;=(n+1)*n&gt;&gt;1;e++) f[n][e]=f[n][e-1]; &#125; T=read();#define sqr(a) ((1ll*(a))*(1ll*(a))%yl) while(T--) &#123; n=read(); e=read(); long long ans=0; for(RG int i=1;i&lt;=n;i++) ans=(1ll*ans+1ll*f[i][min(e, (i-1)*i&gt;&gt;1)]*(n-i+1)%yl*sqr(1ll*frac[n]*inv[i]%yl)%yl)%yl; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BJOI2014】大融合]]></title>
    <url>%2F2018%2F02%2F27%2F%E3%80%90BJOI2014%E3%80%91%E5%A4%A7%E8%9E%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[题面题解LCT维护子树板子题，需要多加理解。推荐Blog 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(1e5+10);int n, q;int fa[maxn], son[2][maxn], size[maxn], vir[maxn], st[maxn], top;bool rev[maxn];inline bool isroot(int x) &#123; return son[0][fa[x]]!=x&amp;&amp;son[1][fa[x]]!=x; &#125;inline bool get_son(int x) &#123; return son[1][fa[x]]==x; &#125;inline void update(int x) &#123; size[x]=size[son[0][x]]+size[son[1][x]]+vir[x]+1; &#125;inline void pushdown(int x)&#123; if(rev[x]) &#123; rev[son[0][x]]^=1; rev[son[1][x]]^=1; rev[x]=0; swap(son[0][x], son[1][x]); &#125;&#125;inline void rotate(int x)&#123; int f=fa[x], g=fa[f], l=get_son(x), r=l^1; if(!isroot(f)) son[get_son(f)][g]=x; fa[x]=g; fa[f]=x; fa[son[r][x]]=f; son[l][f]=son[r][x]; son[r][x]=f; update(f); update(x);&#125;inline void splay(int x)&#123; top=1; st[top]=x; for(RG int i=x;!isroot(i);i=fa[i]) st[++top]=fa[i]; for(RG int i=top;i;i--) pushdown(st[i]); for(;!isroot(x);rotate(x)) if(!isroot(fa[x])) rotate(get_son(fa[x])^get_son(x)?x:fa[x]);&#125;inline void access(int x)&#123; for(RG int t=0;x;t=x, x=fa[x]) splay(x), vir[x]+=size[son[0][x]], vir[x]-=size[son[0][x]=t], update(x);&#125;inline void makeroot(int x) &#123; access(x); splay(x); rev[x]^=1; &#125;inline void split(int x, int y) &#123; makeroot(x); access(y); splay(y); &#125;inline void link(int x, int y) &#123; split(x, y); vir[fa[x]=y]+=size[x]; &#125;char s[3];int a, b;int main()&#123; n=read(); q=read(); for(RG int i=1;i&lt;=n;i++) size[i]=1; while(q--) &#123; scanf("%s", s); a=read(); b=read(); if(s[0]=='A') link(a, b); else split(a, b), printf("%lld\n", 1ll*(vir[a]+1)*(vir[b]+1)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>洛谷</tag>
        <tag>Link_Cut_Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-27考试]]></title>
    <url>%2F2018%2F02%2F27%2F2018-02-27%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[序今天的题目终于正常了(吗?)…T3我的解法原来是骗分 题目T1:矩阵(matrix)T2:洗头(head)T3:铁路(railway) 结果题解T1悬线法什么鬼很好懂的。 T2最小生成树计数本质是搜索 T3(不会)不可做 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(2010);int g[maxn][maxn], up[maxn][maxn], dn[maxn][maxn], ans, n;int main()&#123; n=read(); for(RG int i=1;i&lt;=n;i++) for(RG int j=1;j&lt;=n;j++) g[i][j]=read(), up[i][j]=g[i][j]?0:up[i-1][j]+1; for(RG int i=n;i;i--) for(RG int j=1;j&lt;=n;j++) dn[i][j]=g[i][j]?0:dn[i+1][j]+1; for(RG int i=1;i&lt;=n;i++) &#123; int mup=n, mdn=n, l=0; for(RG int j=1;j&lt;=n;j++) &#123; if(g[i][j]) &#123; mup=mdn=n; l=0; continue; &#125; l++; mup=min(mup, up[i][j]); mdn=min(mdn, dn[i][j]); ans=max(ans, l*(mup+mdn-1)); &#125; &#125; return printf("%d\n", ans)&amp;0;&#125; T21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(1e5+10), mod(31011);struct edge &#123; int u, v, w; &#125; e[maxn];inline bool cmp(const edge &amp;a, const edge &amp;b) &#123; return a.w&lt;b.w; &#125; int n, m, dis[maxn], len, L[maxn], R[maxn], fa[maxn], pre[maxn], mst, ans=1;inline int find(int x) &#123; return fa[x]==x?x:fa[x]=find(fa[x]); &#125;int main()&#123; n=read(); m=read(); for(RG int i=1;i&lt;=m;i++) e[i]=(edge)&#123;read(), read(), read()&#125;, dis[i]=e[i].w; clear(L, 127); sort(e+1, e+m+1, cmp); sort(dis+1, dis+m+1); len=unique(dis+1, dis+m+1)-dis-1; for(RG int i=1;i&lt;=m;i++) &#123; e[i].w=lower_bound(dis+1, dis+len+1, e[i].w)-dis; L[e[i].w] = min(L[e[i].w], i); R[e[i].w] = max(R[e[i].w], i); &#125; for(RG int i=1;i&lt;=n;i++) fa[i]=i; for(RG int t=1;t&lt;=len;t++) &#123; for(RG int i=1;i&lt;=n;i++) pre[i]=fa[i]; int sum=0, tot=0; for(RG int i=L[t];i&lt;=R[t];i++) if(find(e[i].u)^find(e[i].v)) &#123; sum++; (mst+=dis[t])%=mod; fa[find(e[i].u)]=find(e[i].v); &#125; if(!sum) continue; for(RG int i=1, SET=(1&lt;&lt;(R[t]-L[t]+1))-1;i&lt;=SET;i++) &#123; for(RG int j=1;j&lt;=n;j++) fa[j]=pre[j]; int now=0; bool bj=true; for(RG int j=0;j&lt;=R[t]-L[t];j++) if(i&amp;(1&lt;&lt;j)) &#123; if(find(e[j+L[t]].u)^find(e[j+L[t]].v)) now++, fa[find(e[j+L[t]].u)]=find(e[j+L[t]].v); else bj=false; &#125; if(now==sum&amp;&amp;bj) tot++; &#125; ans=1ll*ans*tot%mod; for(RG int i=L[t];i&lt;=R[t];i++) fa[find(e[i].u)]=find(e[i].v); bool bj=true; for(RG int i=2;i&lt;=n;i++) if(find(i)^find(1)) &#123; bj=false; break; &#125; if(bj) return printf("%d %d %d\n", n-1, mst, ans*n%mod)&amp;0; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3690【模板】Link-Cut-Tree（动态树）]]></title>
    <url>%2F2018%2F02%2F26%2F%E6%B4%9B%E8%B0%B7P3690%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91Link-Cut-Tree%EF%BC%88%E5%8A%A8%E6%80%81%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题面题目特点结合了几乎LCT的全部功能，是一道LCT上手好题。PS:加上fread()会快很多 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "rb", stdin);freopen(#x".out", "w+", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;namespace quickIO&#123; const int MAXS = (1&lt;&lt;23); char buf[MAXS], *p; int len; inline int read() &#123; int data=0, w=1; char ch=*p++; while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')&amp;&amp;p-buf&lt;len&amp;&amp;(*p)) ch=*p++; if(ch=='-') w=-1, ch=*p++; while(ch&gt;='0'&amp;&amp;ch&lt;='9'&amp;&amp;p-buf&lt;len&amp;&amp;(*p)) data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=*p++; return data*w; &#125; inline void init() &#123; len = fread(buf,1,MAXS,stdin); buf[len] = '\0'; p=buf; &#125;&#125;using namespace quickIO;const int maxn(300010);int n, m;int val[maxn], xr[maxn], fa[maxn], son[2][maxn], st[maxn], top;bool rev[maxn];inline bool isroot(int x) &#123; return son[0][fa[x]]!=x &amp;&amp; son[1][fa[x]]!=x; &#125;inline bool get_son(int x) &#123; return son[1][fa[x]]==x; &#125;inline void update(int x) &#123; xr[x]=xr[son[0][x]]^xr[son[1][x]]^val[x]; &#125;inline void pushdown(int x)&#123; if(rev[x]) &#123; rev[son[0][x]]^=1; rev[son[1][x]]^=1; rev[x]=0; swap(son[0][x], son[1][x]); &#125;&#125;inline void rotate(int x)&#123; int f=fa[x], g=fa[f], l=get_son(x), r=l^1; if(!isroot(f)) son[get_son(f)][g]=x; fa[x]=g; fa[f]=x; fa[son[r][x]]=f; son[l][f]=son[r][x]; son[r][x]=f; update(f); update(x);&#125;inline void splay(int x)&#123; top=1; st[1]=x; for(RG int i=x;!isroot(i);i=fa[i]) st[++top]=fa[i]; for(RG int i=top;i;i--) pushdown(st[i]); for(;!isroot(x);rotate(x)) if(!isroot(fa[x])) rotate(get_son(fa[x])^get_son(x)?x:fa[x]);&#125;inline void access(int x) &#123; for(RG int t=0;x;t=x, x=fa[x]) splay(x), son[1][x]=t, update(x); &#125;inline void makeroot(int x) &#123; access(x); splay(x); rev[x]^=1; &#125;inline void split(int x, int y) &#123; makeroot(x); access(y); splay(y); &#125;inline void link(int x, int y) &#123; makeroot(x); fa[x]=y; &#125;inline void cut(int x, int y) &#123; split(x, y); if(son[0][y]==x) son[0][y]=0; fa[x]=0; &#125;inline void change(int x, int y) &#123; access(x); splay(x); val[x]=y; update(x); &#125;inline int query(int x, int y) &#123; split(x, y); return xr[y]; &#125;inline int find(int x) &#123; access(x); splay(x); while(son[0][x]) x=son[0][x]; return x; &#125;int main()&#123; init(); n=read(); m=read(); for(RG int i=1;i&lt;=n;i++) val[i]=xr[i]=read(); while(m--) &#123; int ops=read(), x=read(), y=read(); if(ops==0) printf("%d\n", query(x, y)); else if(ops==3) change(x, y); else &#123; int fx=find(x), fy=find(y); if(fx==fy &amp;&amp; ops==2) cut(x, y); if(fx!=fy &amp;&amp; ops==1) link(x, y); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>洛谷</tag>
        <tag>Link_Cut_Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2008】洞穴勘测]]></title>
    <url>%2F2018%2F02%2F26%2F%E3%80%90SDOI2008%E3%80%91%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[题面题解LCT判连通性，不多说。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(1e4+10);int n, m;int fa[maxn], son[2][maxn], stk[maxn], top;bool rev[maxn];inline bool isroot(int x) &#123; return son[0][fa[x]]!=x&amp;&amp;son[1][fa[x]]!=x; &#125;inline bool get_son(int x) &#123; return son[1][fa[x]]==x; &#125;inline void pushdown(int x)&#123; if(rev[x]) &#123; rev[son[0][x]]^=1; rev[son[1][x]]^=1; rev[x]=0; swap(son[0][x], son[1][x]); &#125;&#125;inline void rotate(int x)&#123; int f=fa[x], g=fa[f], l=get_son(x), r=l^1; if(!isroot(f)) son[get_son(f)][g]=x; fa[x]=g; fa[f]=x; fa[son[r][x]]=f; son[l][f]=son[r][x]; son[r][x]=f;&#125;inline void splay(int x)&#123; top=1; stk[top]=x; for(RG int i=x;!isroot(i);i=fa[i]) stk[++top]=fa[i]; for(RG int i=top;i;i--) pushdown(stk[i]); for(;!isroot(x);rotate(x)) if(!isroot(fa[x])) rotate(get_son(fa[x])^get_son(x)?x:fa[x]);&#125;inline void access(int x) &#123; for(RG int t=0;x;t=x, x=fa[x]) splay(x), son[1][x]=t; &#125;inline void makeroot(int x) &#123; access(x); splay(x); rev[x]^=1; &#125;inline void split(int x, int y) &#123; makeroot(x); access(y); splay(y); &#125;inline void link(int x, int y) &#123; makeroot(x); fa[x]=y; &#125;inline void cut(int x, int y) &#123; split(x, y); if(son[0][y]==x) son[0][y]=0; fa[x]=0; &#125;inline int find(int x) &#123; access(x); splay(x); while(son[0][x]) x=son[0][x]; return x; &#125;char s[10];int a, b;int main()&#123; n=read(); m=read(); while(m--) &#123; scanf("%s", s); a=read(); b=read(); if(s[0]=='C') link(a, b); else if(s[0]=='D') cut(a, b); else puts(find(a) == find(b) ? "Yes" : "No"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>Link_Cut_Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-26考试]]></title>
    <url>%2F2018%2F02%2F26%2F2018-02-26%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[序今天考试，李老师说题目有点难度，结果…果……果……果然是有难度20分收场 结果题目T1 T2 代码 + 题解T112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/************************************* * 彩色圆环 By xgzc. * * 状态：AC * * 极难题 * ************************************* *先考虑序列 *设f[i][0/1]表示前i个珠子,最后1个珠子和第1个珠子颜色不同(相同)的期望值 *设g[i]表示i个珠子连续1个颜色的概率 *f[i][0]=∑(i-j)*g[i-j]*(f[j][0]*(m-2)/m+f[j][1]*(m-1)/m); *f[i][1]=∑(i-j)*g[i-j]*f[j][0]/m; *初始 f[0][1]=1; *然后处理环形 *首先将g[n]*n累加进答案 *我们可以枚举第一段有多长.如果长度为x,那么就可以有x个位置 *所以对于每个x,将x*x*f[n-x][0]*g[x]累加进答案 *时间复杂度 O(n^2) */#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(210);int n;long double ans, f[maxn][2], g[maxn], m;int main()&#123; n=read(); m=read(); g[1]=f[0][1]=1.0000; for(RG int i=2;i&lt;=n;i++) g[i]=g[i-1]/m; for(RG int i=0;i&lt;n;i++) for(RG int j=i+1;j&lt;=n;j++) &#123; f[j][0]+=(j-i)*g[j-i]*(f[i][0]*(m-2.0000)/m+f[i][1]*(m-1.0000)/m); f[j][1]+=(j-i)*g[j-i]*f[i][0]/m; &#125; ans=g[n]*n; for(RG int i=1;i&lt;n;i++) ans+=1.0000*i*i*f[n-i][0]*g[i]; printf("%.10Lf\n", ans); return 0;&#125; T2(还没做) 总结没什么好总结的]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1501【国家集训队】Tree_II]]></title>
    <url>%2F2018%2F02%2F25%2F%E6%B4%9B%E8%B0%B7P1501%E3%80%90%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%91Tree-II%2F</url>
    <content type="text"><![CDATA[题面题解LCT维护链上求和，下放懒标记模板。记得先乘后加即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "rb", stdin);freopen(#x".out", "w+", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010), mod(51061);int n, q;int val[maxn], sum[maxn], lzmul[maxn], lzadd[maxn], fa[maxn], son[2][maxn], st[maxn], top, size[maxn];bool rev[maxn];inline bool isroot(int x) &#123; return son[0][fa[x]]!=x &amp;&amp; son[1][fa[x]]!=x; &#125;inline bool get_son(int x) &#123; return son[1][fa[x]]==x; &#125;inline void update(int x) &#123; sum[x]=(1ll*sum[son[0][x]]+sum[son[1][x]]+val[x])%mod; size[x]=size[son[0][x]]+size[son[1][x]]+1; &#125;inline void psmul(int x, int v)&#123; if(x==0) return; sum[x]=1ll*sum[x]*v%mod; lzmul[x]=1ll*lzmul[x]*v%mod; val[x]=1ll*val[x]*v%mod; lzadd[x]=1ll*lzadd[x]*v%mod;&#125;inline void psadd(int x, int v)&#123; if(x==0) return; sum[x]=(1ll*sum[x]+1ll*size[x]*v)%mod; val[x]=(1ll*val[x]+v)%mod; lzadd[x]=(1ll*lzadd[x]+v)%mod;&#125;inline void pushdown(int x)&#123; if(lzmul[x]!=1) psmul(son[0][x], lzmul[x]), psmul(son[1][x], lzmul[x]), lzmul[x]=1; if(lzadd[x]) psadd(son[0][x], lzadd[x]), psadd(son[1][x], lzadd[x]), lzadd[x]=0; if(rev[x]) &#123; if(son[0][x]) rev[son[0][x]]^=1; if(son[1][x]) rev[son[1][x]]^=1; rev[x]=0; swap(son[0][x], son[1][x]); &#125;&#125;inline void rotate(int x)&#123; int f=fa[x], g=fa[f], l=get_son(x), r=l^1; if(!isroot(f)) son[get_son(f)][g]=x; fa[x]=g; fa[f]=x; fa[son[r][x]]=f; son[l][f]=son[r][x]; son[r][x]=f; update(f); update(x);&#125;inline void splay(int x)&#123; top=1; st[top]=x; for(RG int i=x;!isroot(i);i=fa[i]) st[++top]=fa[i]; for(RG int i=top;i;i--) pushdown(st[i]); for(;!isroot(x);rotate(x)) if(!isroot(fa[x])) rotate(get_son(fa[x])^get_son(x)?x:fa[x]);&#125;inline void access(int x) &#123; for(RG int t=0;x;t=x, x=fa[x]) splay(x), son[1][x]=t, update(x); &#125;inline void makeroot(int x) &#123; access(x); splay(x); rev[x]^=1; &#125;inline void split(int x, int y) &#123; makeroot(x); access(y); splay(y); &#125;inline void link(int x, int y) &#123; makeroot(x); fa[x]=y; &#125;inline void cut(int x, int y) &#123; split(x, y); if(son[0][y]==x) son[0][y]=0; fa[x]=0; &#125;inline void mul(int x, int y, int v) &#123; split(x, y); psmul(y, v); &#125;inline void add(int x, int y, int v) &#123; split(x, y); psadd(y, v); &#125;inline int query(int x, int y) &#123; split(x, y); return sum[y]; &#125;int a, b, c, d;char s[3];int main()&#123; n=read(); q=read(); for(RG int i=1;i&lt;=n;i++) val[i]=size[i]=lzmul[i]=1; for(RG int i=1;i&lt;n;i++) a=read(), b=read(), link(a, b); while(q--) &#123; scanf("%s", s); a=read(); b=read(); if(s[0]=='+') c=read(), add(a, b, c); else if(s[0]=='-') c=read(), d=read(), cut(a, b), link(c, d); else if(s[0]=='*') c=read(), mul(a, b, c); else printf("%d\n", query(a, b)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>Link_Cut_Tree</tag>
        <tag>CJOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-24考试]]></title>
    <url>%2F2018%2F02%2F24%2F2018-02-24%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[题目T1: [POI2006]KRA-The DisksT2: [POI2007]POW-The FloodT3: [POI2007]MEG-MegalopolisT4: [POI2006]ORK-Ploughing 结果主要题解T2我们知道，如果一个点和一个海拔不高于它的点相连那么连在那个点是更优的，所以考虑按照每个点的海拔排序既然按照海拔排序，相邻的海拔递增的点可以放在同一个集合里面讨论考虑使用并查集，每一个集合中只需要有一个抽水机即可 每次从海拔最低的点中选出一个点将它和它周围的海拔比当前海拔低的点直接链接在一起同时，维护每个并查集是否存在抽水机如果当前点是城市，并且所在的并查集中有抽水机了显然是不用再额外增加抽水机了但是，如果当前点和周围的点合并完之后，所在集合依然没有抽水机因为它所在的集合周围的点海拔一定更高，不可能有抽水机所以在当前集合中一点要放一个抽水机，那么，给当前集合放一个抽水机，同时答案加一即可 T4难度较大我们知道，如果我们选定了以横向为主，或者纵向为主，那么就有尽可能减少另一个方向上耕地的次数 所以分开贪心，但是本质相同，所以接下来只考虑纵向为主 既然确定了以纵向为主，那么就要尽可能减少横向操作的次数所以，只要能够纵向耕地，就不考虑横向耕地可是，如果到了某个时候，纵向无法耕了此时必须横向耕但是我们不知道应该从上面开始还是下面开始 为了解决这个问题我们假设上面最多耕的次数是有限次换种想法，我们假设上面至少耕这么多次既然上面的次数确定，那么下方的耕地次数越少越好所以耕地的优先级：左-右-上-下只要能够耕就一定耕这样，枚举-贪心的做法就可以做啦横向、纵向分别算一遍时间复杂度$O((n+m)^2)$ 代码T1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(300010);int n, m, r[maxn], k[maxn], b[maxn &lt;&lt; 1], cnt, val[maxn], minv[maxn &lt;&lt; 2], ans;map&lt;int, int&gt; id;#define son(i) ((root &lt;&lt; 1) | i)inline void build(int root=1, int l=1, int r=n)&#123; if(l==r) &#123; minv[root]=val[l]; return; &#125; int mid(l+r&gt;&gt;1); build(son(0), l, mid); build(son(1), mid+1, r); minv[root]=min(minv[son(0)], minv[son(1)]);&#125;const int I(2147483647);inline int query(int ql, int qr, int root=1, int l=1, int r=n)&#123; if(r&lt;ql || l&gt;qr) return I; if(ql&lt;=l &amp;&amp; r&lt;=qr) return minv[root]; int mid(l+r&gt;&gt;1); return min(query(ql, qr, son(0), l, mid), query(ql, qr, son(1), mid+1, r));&#125;int main()&#123; n=read(); m=read(); for(RG int i=1;i&lt;=n;i++) r[i]=b[i]=read(); for(RG int i=1;i&lt;=m;i++) k[i]=b[n+i]=read(); sort(b+1, b+n+m+1); cnt=unique(b+1, b+n+m+1)-b-1; for(RG int i=1;i&lt;=cnt;i++) id[b[i]]=i; for(RG int i=1;i&lt;=n;i++) &#123; r[i]=id[r[i]]; if(!val[r[i]]) val[r[i]]=i; &#125; for(RG int i=1;i&lt;=cnt;i++) if(!val[i]) val[i]=n+1; for(RG int i=1;i&lt;=m;i++) k[i]=id[k[i]]; build(); ans=n+1; for(RG int i=1;i&lt;=m;i++) &#123; if(k[i]==1) ans--; else &#123; int x=query(1, k[i]-1)-1; ans=min(ans-1, x); &#125; if(ans==0) break; &#125; printf("%d\n", ans); return 0;&#125; T21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(1010);const int x[4]=&#123;1, 0, -1, 0&#125;;const int y[4]=&#123;0, 1, 0, -1&#125;;struct point &#123; int a, b, h; &#125; p[maxn * maxn];int fa[maxn * maxn], n, m, cnt, high, ans, g[maxn][maxn];bool put[maxn * maxn], need[maxn * maxn];inline int find(const int &amp;x) &#123; return fa[x]==x ? x : fa[x]=find(fa[x]); &#125;inline int num(const point &amp;p) &#123; return (p.a-1)*m+p.b; &#125;inline int num(const int &amp;a, const int &amp;b) &#123; return (a-1)*m+b; &#125;inline bool cmp(const point &amp;a, const point &amp;b) &#123; return a.h&lt;b.h; &#125;int main()&#123; n=read(); m=read(); for(RG int i=1;i&lt;=n;i++) for(RG int j=1;j&lt;=m;j++) &#123; p[++cnt]=(point)&#123;i, j, abs(g[i][j]=read())&#125;; int k(num(p[cnt])); if(g[i][j]&gt;0) need[k]=true; else g[i][j]=-g[i][j]; fa[k]=k; &#125; sort(p+1, p+cnt+1, cmp); int pos=1; for(RG int i=1;i&lt;=cnt;i++) &#123; int fx=find(num(p[i])); for(RG int j=0;j&lt;4;j++) &#123; int _=p[i].a+x[j], __=p[i].b+y[j]; if(!(_&gt;0&amp;&amp;__&gt;0&amp;&amp;_&lt;=n&amp;&amp;__&lt;=m)) continue; if(g[_][__]&gt;g[p[i].a][p[i].b]) continue; int fy=find(num(_, __)); if(fx!=fy) fa[fx]=fy, put[fy]|=put[fx]; fx=find(fx); &#125; if((!put[fx])&amp;&amp;p[i].h&lt;p[i+1].h) for(RG int j=pos;j&lt;=i;j++) if(need[j]) &#123; ans++; put[fx]=true; break; &#125; if(p[i].h&lt;p[i+1].h) pos=i+1; &#125; printf("%d\n", ans); return 0;&#125; T3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define for_edge(i, x) for(RG int i=head[x];i;i=e[i].next)#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(1e5+10);struct edge &#123; int next, to; &#125; e[maxn &lt;&lt; 1];int head[maxn], e_num, n, m;inline void add_edge(int from, int to) &#123; e[++e_num]=(edge)&#123;head[from], to&#125;; head[from]=e_num; &#125;int fa[maxn], size[maxn], heavy[maxn], val[maxn];void dfs(int x)&#123; size[x]=1; int _max=0; for_edge(i, x) &#123; int to=e[i].to; if(to==fa[x]) continue; fa[to]=x; dfs(to); size[x]+=size[to]; if(_max &lt; size[to]) _max=size[to], heavy[x]=to; &#125;&#125;int pos[maxn], cnt_pos[maxn], belong[maxn], cnt_node;void dfs(int x, int chain)&#123; belong[x]=chain; pos[x]=++cnt_node; cnt_pos[cnt_node]=x; int k=heavy[x]; if(!k) return; dfs(k, chain); for_edge(i, x) &#123; int to=e[i].to; if(to==fa[x] || to==k) continue; dfs(to, to); &#125;&#125;int sum[maxn &lt;&lt; 2];#define son(i) ((root&lt;&lt;1)|i)inline void build(int root=1, int l=1, int r=cnt_node)&#123; if(l==r) &#123; sum[root]=val[cnt_pos[l]]; return; &#125; int mid(l+r&gt;&gt;1); build(son(0), l, mid); build(son(1), mid+1, r); sum[root]=sum[son(0)]+sum[son(1)];&#125;inline void update(int id, int root=1, int l=1, int r=cnt_node)&#123; if(l==r) &#123; sum[root]=0; return; &#125; int mid(l+r&gt;&gt;1); if(id&lt;=mid) update(id, son(0), l, mid); else update(id, son(1), mid+1, r); sum[root]=sum[son(0)]+sum[son(1)];&#125;inline int query(int ql, int qr, int root=1, int l=1, int r=cnt_node)&#123; if(r&lt;ql || l&gt;qr) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sum[root]; int mid(l+r&gt;&gt;1); return query(ql, qr, son(0), l, mid)+query(ql, qr, son(1), mid+1, r);&#125;inline int query_chain(int a)&#123; int ans=0; while(belong[a]!=1) &#123; ans+=query(pos[belong[a]], pos[a]); a=fa[belong[a]]; &#125; ans+=query(1, pos[a]); return ans;&#125;char s[3];int a, b;int main()&#123; n=read(); for(RG int i=1;i&lt;n;i++) a=read(), b=read(), add_edge(a, b), add_edge(b, a), val[i+1]=1; dfs(1); dfs(1, 1); build(); m=read(); for(RG int i=1;i&lt;n+m;i++) &#123; scanf("%s", s); a=read(); if(s[0]=='W') printf("%d\n", query_chain(a)); else b=read(), update(pos[b]); &#125; return 0;&#125; T41234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(2010);#define orz [maxn][maxn]int g orz, s1 orz, s2 orz, n, m, K;inline int Tanl(int l)&#123; int l1=1, l2=n, r1=1, r2=m, ans=0; while(l1&lt;=l2 &amp;&amp; r1&lt;=r2) &#123; ans++; if(s1[l1][r2]-s1[l1][r1-1]&lt;=K) &#123; l1++; continue; &#125; if(s1[l2][r2]-s1[l2][r1-1]&lt;=K) &#123; l2--; continue; &#125; if(s2[l2][r1]-s2[l1-1][r1]&lt;=K &amp;&amp; r1&lt;l) &#123; r1++; continue; &#125; if(s2[l2][r2]-s2[l1-1][r2]&lt;=K) &#123; r2--; continue; &#125; ans=2147483647; break; &#125; return ans;&#125;inline int Tanu(int u)&#123; int l1=1, l2=n, r1=1, r2=m, ans=0; while(l1&lt;=l2 &amp;&amp; r1&lt;=r2) &#123; ans++; if(s2[l2][r1]-s2[l1-1][r1]&lt;=K) &#123; r1++; continue; &#125; if(s2[l2][r2]-s2[l1-1][r2]&lt;=K) &#123; r2--; continue; &#125; if(s1[l1][r2]-s1[l1][r1-1]&lt;=K &amp;&amp; l1&lt;u) &#123; l1++; continue; &#125; if(s1[l2][r2]-s1[l2][r1-1]&lt;=K) &#123; l2--; continue; &#125; ans=2147483647; break; &#125; return ans;&#125;int ans=2147483647;int main()&#123; K=read(); m=read(); n=read(); for(RG int i=1;i&lt;=n;i++) for(RG int j=1;j&lt;=m;j++) g[i][j]=read(), s2[i][j]=s2[i-1][j]+g[i][j], s1[i][j]=s1[i][j-1]+g[i][j]; for(RG int i=1;i&lt;=n;i++) ans=min(ans, Tanu(i)); for(RG int i=1;i&lt;=m;i++) ans=min(ans, Tanl(i)); printf("%d\n", ans); return 0;&#125; 总结在开考前，李老师跟我们说这套题很简单，但是我并没有想出稍微难一点的两道题，而只打了骗分暴力。看来我以后还要多加练习，开拓思路。]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-23考试]]></title>
    <url>%2F2018%2F02%2F23%2F2018-02-23%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[题目结果题解T1Tarjian判环板子题… T2较简单的DP $f(i,\;j)=f(i-j,\;j)+f(i-1,\;j-1)$ T3最大子矩阵板子题 代码T1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define for_edge(i, x) for(RG int i=head[x];i;i=e[i].next)#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;#define yes "Yes"#define no "No"const int maxn(2e4+10), maxm(1e5+10);struct edge &#123; int next, to; &#125; e[maxm];int head[maxn], e_num, T, n, m, a, b, dfn[maxn], low[maxn], stk[maxn], top, cnt;bool tag, vis[maxn];inline void add_edge(int from, int to) &#123; e[++e_num]=(edge)&#123;head[from], to&#125;; head[from]=e_num; &#125;inline void pop(int u)&#123; int x=0; while(stk[top]!=u) vis[stk[top]]=false, top--, x++; vis[stk[top]]=false; top--; x++; if(x&gt;1) tag=true;&#125;inline void Tarjian(int x)&#123; low[x]=dfn[x]=++cnt; stk[++top]=x; vis[x]=true; for_edge(i, x) &#123; int to=e[i].to; if(!dfn[to]) &#123; Tarjian(to); low[x]=min(low[x], low[to]); &#125; else if(vis[to]) low[x]=min(low[x], dfn[to]); &#125; if(dfn[x]==low[x]) pop(x);&#125;int main()&#123; T=read(); while(T--) &#123; clear(head, 0); e_num=0; clear(dfn, 0); clear(low, 0); n=read(); m=read(); tag=false; cnt=0; for(RG int i=1;i&lt;=m;i++) &#123; a=read(); b=read(); add_edge(a, b); &#125; for(RG int i=1;i&lt;=n;i++) if(!dfn[i]) Tarjian(i); if(tag) puts(no); else puts(yes); &#125; return 0;&#125; T2123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int mod(19940714), maxn(2010);int n, m, f[maxn][maxn], ans;int main()&#123; n=read(); m=read(); f[0][0]=1; m=min(m, n); for(RG int i=1;i&lt;=n;i++) for(RG int j=1;j&lt;=min(m, i);j++) f[i][j]=(f[i-j][j]+f[i-1][j-1])%mod; for(RG int i=1;i&lt;=m;i++) ans=(ans+f[n][i])%mod; printf("%d\n", ans); return 0;&#125; T3123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;#define int long longconst int maxn(310);int g[maxn][maxn], n, m, a, b, c, f[maxn], ans;main()&#123; n=read(); m=read(); for(RG int i=1;i&lt;=m;i++) a=read(), b=read(), c=read(), g[a][b]+=c; for(RG int i=1;i&lt;=n;i++) for(RG int j=1;j&lt;=n;j++) g[i][j]+=g[i][j-1]; for(RG int i=1;i&lt;=n;i++) for(RG int j=i;j&lt;=n;j++) &#123; RG int s=0; for(RG int k=1;k&lt;=n;k++) &#123; s+=g[k][j]-g[k][i-1]; if(s&lt;0) s=0; ans=max(ans, s); &#125; &#125; printf("%lld\n", ans); return 0;&#125; 总结 :第三题 最大子矩阵不会做，爆凌了 只有200分HYJ大佬290(Orz) 我还是太弱辣!]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-22考试]]></title>
    <url>%2F2018%2F02%2F22%2F2018-02-22%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[序今天我没考试，看了一下题目，觉得挺有难度的，就做了一下。 题目T1:勇斗恶龙(fight)T2:崎岖的山路(road)T3:线路铺设(line)PS:题解不贴了 代码T112345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;inline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;#define win "Win\n"#define lose "Lose\n"priority_queue&lt;int&gt; heap;int n, x, y, a, b, c, B, maxb;int main()&#123; n=read(); x=read(); y=read(); a=read(); B=b=read(); for(RG int i=1;i&lt;=n;i++) &#123; c=read(); heap.push(c); a-=c; b-=x; maxb=max(maxb, B-b); if(b&lt;=0) return printf(win"%d\n", i)&amp;0; if(a&lt;=0) &#123; int t=heap.top(); heap.pop(); a+=max(t, y); b+=x; &#125; &#125; return printf(lose"%d\n", maxb)&amp;0;&#125; T2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "rb", stdin);freopen(#x".out", "w+", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;namespace quickIO&#123; const int MAXS = (1&lt;&lt;23); char buf[MAXS], *p; int len; inline int read() &#123; int data=0, w=1; char ch=*p++; while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')&amp;&amp;p-buf&lt;len&amp;&amp;(*p)) ch=*p++; if(ch=='-') w=-1, ch=*p++; while(ch&gt;='0'&amp;&amp;ch&lt;='9'&amp;&amp;p-buf&lt;len&amp;&amp;(*p)) data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=*p++; return data*w; &#125; inline void init() &#123; len = fread(buf,1,MAXS,stdin); buf[len] = '\0'; p=buf; &#125;&#125;using namespace quickIO;const int maxn(100010);struct node &#123; int val, dis; node *son[2]; node(int v) &#123; val=v; dis=1; son[0]=son[1]=NULL; &#125; &#125; *stk[maxn];int tp, n, size[maxn], l[maxn], r[maxn], val[maxn];inline int dis(node *x) &#123; return x ? x-&gt;dis : 0; &#125;inline void update(node *x) &#123; if(dis(x-&gt;son[0])&lt; dis(x-&gt;son[1])) swap(x-&gt;son[0], x-&gt;son[1]); x-&gt;dis=dis(x-&gt;son[1])+1; &#125;inline node *merge(node *x, node *y)&#123; if(x==NULL) return y; if(y==NULL) return x; if(x-&gt;val &lt; y-&gt;val) swap(x, y); x-&gt;son[1]=merge(x-&gt;son[1], y); update(x); return x;&#125;inline int v(node *x) &#123; return x ? x-&gt;val : 0; &#125;int main()&#123; init(); n=read(); for(RG int i=1;i&lt;=n;i++) &#123; val[i]=read(); stk[++tp]=new node(val[i]); l[tp]=r[tp]=i; size[tp]=1; if(!(tp-1)) continue; while(v(stk[tp])&lt;v(stk[tp-1])) &#123; tp--; stk[tp]=merge(stk[tp], stk[tp+1]); r[tp]=r[tp+1]; size[tp]+=size[tp+1]; while(size[tp]&gt;((r[tp]-l[tp]+2)&gt;&gt;1)) stk[tp]=merge(stk[tp]-&gt;son[0], stk[tp]-&gt;son[1]), size[tp]--; &#125; &#125; long long ans=0; for(RG int i=1;i&lt;=tp;i++) for(RG int j=l[i];j&lt;=r[i];j++) ans+=abs(val[j]-v(stk[i])); printf("%lld\n", ans); return 0;&#125; T3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define for_edge(i, x) for(RG int i=head[x];i;i=e[i].next)#define clear(x, y) memset(x, y, sizeof(x));using namespace std;#define int long longinline int read()&#123; int data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(50010), maxm(100010);struct edge &#123; int next, to, dis; &#125; e[maxm&lt;&lt;1];int head[maxn], e_num, val[maxn], n, m;inline void add_edge(int from, int to, int dis) &#123; e[++e_num]=(edge)&#123;head[from], to, dis&#125;; head[from]=e_num; &#125;int dis[maxn];queue&lt;int&gt; q; bool vis[maxn];inline void spfa()&#123; clear(dis, 127); q.push(1); vis[1]=true; dis[1]=0; while(!q.empty()) &#123; int x=q.front(); q.pop(); for_edge(i, x) &#123; int to=e[i].to; if(dis[to] &gt; dis[x] + e[i].dis) &#123; dis[to]=dis[x]+e[i].dis; if(!vis[to]) vis[to]=true, q.push(to); &#125; &#125; vis[x]=false; &#125;&#125;int a, b, c, ans;#undef intint main()&#123; #define int long long n=read(); m=read(); for(RG int i=1;i&lt;=n;i++) val[i]=read(); for(RG int i=1;i&lt;=m;i++) a=read(), b=read(), c=read(), add_edge(a, b, c); spfa(); for(RG int i=1;i&lt;=n;i++) &#123; if(dis[i]==dis[0]) return puts("No Answer")&amp;0; ans+=dis[i]*val[i]; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-10考试]]></title>
    <url>%2F2018%2F02%2F10%2F2018-02-10%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[题目：题目在这里 题解在这里 代码：T1 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(5000010);char a[maxn], b[maxn]; int len, n, pos;struct node &#123; char c; int id; &#125; q[maxn];int head, tail;inline void push(int x)&#123; while(head&lt;=tail&amp;&amp;q[tail].c&gt;a[x]) tail--; q[++tail]=(node)&#123;a[x], x&#125;; while(q[head].id&lt;=pos) head++;&#125;int main()&#123; scanf("%s", a); len=strlen(a); n=len-read&lt;int&gt;(); head=1; tail=0; pos=-1; for(RG int i=0;i&lt;len-n+1;i++) push(i); for(RG int i=len-n+1;i&lt;len;i++) &#123; char ans=q[head].c; pos=q[head].id; b[i-(len-n+1)]=ans; push(i); &#125; char ans=q[head].c; b[n-1]=ans; int p=0; while((!(b[p]^48)) &amp;&amp; p&lt;n-1) p++; puts(b+p); return 0;&#125; T2 :1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(250010);int n, x[maxn], y[maxn];long long l;priority_queue&lt;int&gt; heap;int main()&#123; n=read&lt;int&gt;(); for(RG int i=1;i&lt;=n;i++) x[i]=read&lt;int&gt;(); for(RG int i=1;i&lt;=n;i++) y[i]=read&lt;int&gt;(); for(RG int i=1;i&lt;=n;i++) &#123; l+=x[i]; heap.push(y[i]); l-=y[i]; if(l&lt;0) &#123; l+=heap.top(); heap.pop(); &#125; &#125; printf("%d\n", heap.size()); return 0;&#125; T3 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define for_edge(i, x) for(RG int i=head[x];i;i=e[i].next)#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010), maxm(300010);struct edge&#123; int next, to; long long dis;&#125; e[maxn &lt;&lt; 1];int head[maxn], e_num;inline void add_edge(int from, int to, long long dis)&#123; e[++e_num]=&#123;head[from], to, dis&#125;; head[from]=e_num;&#125;struct edge_k &#123; int from, to; long long dis; &#125; edg[maxm];inline bool cmp(const edge_k &amp;a, const edge_k &amp;b) &#123; return a.dis&lt;b.dis; &#125;int fa[maxn], n, m;long long value; bool use[maxm];inline int find(const int &amp;x) &#123; return fa[x] == x ? x : fa[x]=find(fa[x]); &#125;inline void mst()&#123; long long ans=0; for(RG int i=1;i&lt;=n;i++) fa[i]=i; for(RG int i=1;i&lt;=m;i++) &#123; int x=find(edg[i].from), y=find(edg[i].to); if(x!=y) &#123; fa[max(x, y)]=min(x, y); ans+=edg[i].dis; use[i]=true; add_edge(edg[i].from, edg[i].to, edg[i].dis); add_edge(edg[i].to, edg[i].from, edg[i].dis); &#125; &#125; value = ans;&#125;long long fst[maxn][18], sec[maxn][18], ANS=0;int f[maxn][18], deep[maxn];inline void dfs(int x)&#123; for_edge(i, x) &#123; int to=e[i].to; long long ds=e[i].dis; if(to==f[x][0]) continue; f[to][0]=x; fst[to][0]=sec[to][0]=ds; deep[to]=deep[x]+1; dfs(to); &#125;&#125;inline void get_sec(long long &amp;sec, long long a, long long b, long long c, long long d, long long _max)&#123; if(a&lt;_max) sec=a; if(b&lt;_max) sec=max(sec, b); if(c&lt;_max) sec=max(sec, c); if(d&lt;_max) sec=max(sec, d);&#125;inline void init()&#123; dfs(1); for(RG int j=1;j&lt;18;j++) for(RG int i=1;i&lt;=n;i++) &#123; f[i][j]=f[f[i][j-1]][j-1]; long long f1=fst[i][j-1], f2=fst[f[i][j-1]][j-1], s1=sec[i][j-1], s2=sec[f[i][j-1]][j-1]; fst[i][j]=max(f1, f2); get_sec(sec[i][j], f1, f2, s1, s2, fst[i][j]); &#125;&#125;inline long long query(int a, int b, long long dis)&#123; if(deep[a]&lt;deep[b]) swap(a, b); long long fsa=-1, sca=-1, fsb=-1, scb=-1; int d=deep[a]-deep[b]; for(RG int i=0;(1&lt;&lt;i)&lt;=d;i++) &#123; if((1&lt;&lt;i)&amp;d) &#123; long long tmp=sca; get_sec(sca, fsa, fst[a][i], tmp, sec[a][i], max(fsa, fst[a][i])); fsa=max(fsa, fst[a][i]); a=f[a][i]; &#125; &#125; if(a==b) &#123; long long tmp=sca; get_sec(sca, fsa, fsb, tmp, scb, max(fsa, fsb)); if(dis==max(fsa, fsb)) return value-sca+dis; else return value-max(fsa, fsb)+dis; &#125; for(RG int i=17;~i;i--) &#123; if(f[a][i]!=f[b][i]) &#123; long long tmp=sca; get_sec(sca, fsa, fst[a][i], tmp, sec[a][i], max(fsa, fst[a][i])); fsa=max(fsa, fst[a][i]); a=f[a][i]; tmp=scb; get_sec(scb, fsb, fst[b][i], tmp, sec[b][i], max(fsb, fst[b][i])); fsb=max(fsb, fst[b][i]); b=f[b][i]; &#125; &#125; long long tmp=sca; get_sec(sca, fsa, fst[a][0], tmp, sec[a][0], max(fsa, fst[a][0])); fsa=max(fsa, fst[a][0]); a=f[a][0]; tmp=scb; get_sec(scb, fsb, fst[b][0], tmp, sec[b][0], max(fsb, fst[b][0])); fsb=max(fsb, fst[b][0]); b=f[b][0]; tmp=sca; get_sec(sca, fsa, fsb, tmp, scb, max(fsa, fsb)); if(dis==max(fsa, fsb)) return value-sca+dis; else return value-max(fsa, fsb)+dis;&#125;const long long I(9223372036854775807ll);int main()&#123; n=read&lt;int&gt;(); m=read&lt;int&gt;(); for(RG int i=1;i&lt;=m;i++) edg[i].from=read&lt;int&gt;(), edg[i].to=read&lt;int&gt;(), edg[i].dis=read&lt;long long&gt;(); sort(edg+1, edg+m+1, cmp); mst(); init(); ANS=I; for(RG int i=1;i&lt;=m;i++) if(!use[i]) ANS=min(ANS, query(edg[i].from, edg[i].to, edg[i].dis)); printf("%lld\n", ANS); return 0;&#125; 总结 :第二题我并没有想出贪心策略，说明我的贪心练得还不够，以后还要多加练习(看来我还是太弱啦)。]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4180【Beijing2010组队】次小生成树Tree]]></title>
    <url>%2F2018%2F02%2F09%2F%E6%B4%9B%E8%B0%B7P4180%E3%80%90Beijing2010%E7%BB%84%E9%98%9F%E3%80%91%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Tree%2F</url>
    <content type="text"><![CDATA[题目描述:小C最近学了很多最小生成树的算法，Prim算法、Kurskal算法、消圈算法等等。正当小C洋洋得意之时，小P又来泼小C冷水了。小P说，让小C求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是$E_M$，严格次小生成树选择的边集是$E_S$，那么需要满足：($value(e)$表示边e的权值) 这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。 输入输出格式:输入格式:第一行包含两个整数N和M，表示无向图的点数与边数。接下来M行，每行3个数 x y z 表示，点x和点y之间有一条边，边的权值为z。 输出格式:包含一行，仅一个数，表示严格次小生成树的边权和。(数据保证必定存在严格次小生成树) 输入输出样例:输入样例:12345675 61 2 11 3 22 4 33 5 43 4 34 5 6 输出样例:111 说明:数据中无向图无自环50%的数据$N≤2000,\;M≤3000$80%的数据$N≤50000,\;M≤100000$100%的数据$N≤100000,\;M≤300000$, 边权值非负且不超过$10^9$。 SOL:首先求出最小生成树，然后将最小生成树的边依次断开，换成指定的一条边，求出这个环中最长的一条边，换掉即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define for_edge(i, x) for(RG int i=head[x];i;i=e[i].next)#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010), maxm(300010);struct edge&#123; int next, to; long long dis;&#125; e[maxn &lt;&lt; 1];int head[maxn], e_num;inline void add_edge(int from, int to, long long dis)&#123; e[++e_num]=&#123;head[from], to, dis&#125;; head[from]=e_num;&#125;struct edge_k &#123; int from, to; long long dis; &#125; edg[maxm];inline bool cmp(const edge_k &amp;a, const edge_k &amp;b) &#123; return a.dis&lt;b.dis; &#125;int fa[maxn], n, m;long long value; bool use[maxm];inline int find(const int &amp;x) &#123; return fa[x] == x ? x : fa[x]=find(fa[x]); &#125;inline void mst()&#123; long long ans=0; for(RG int i=1;i&lt;=n;i++) fa[i]=i; for(RG int i=1;i&lt;=m;i++) &#123; int x=find(edg[i].from), y=find(edg[i].to); if(x!=y) &#123; fa[max(x, y)]=min(x, y); ans+=edg[i].dis; use[i]=true; add_edge(edg[i].from, edg[i].to, edg[i].dis); add_edge(edg[i].to, edg[i].from, edg[i].dis); &#125; &#125; value = ans;&#125;long long fst[maxn][18], sec[maxn][18], ANS=0;int f[maxn][18], deep[maxn];inline void dfs(int x)&#123; for_edge(i, x) &#123; int to=e[i].to; long long ds=e[i].dis; if(to==f[x][0]) continue; f[to][0]=x; fst[to][0]=sec[to][0]=ds; deep[to]=deep[x]+1; dfs(to); &#125;&#125;inline void get_sec(long long &amp;sec, long long a, long long b, long long c, long long d, long long _max)&#123; if(a&lt;_max) sec=a; if(b&lt;_max) sec=max(sec, b); if(c&lt;_max) sec=max(sec, c); if(d&lt;_max) sec=max(sec, d);&#125;inline void init()&#123; dfs(1); for(RG int j=1;j&lt;18;j++) for(RG int i=1;i&lt;=n;i++) &#123; f[i][j]=f[f[i][j-1]][j-1]; long long f1=fst[i][j-1], f2=fst[f[i][j-1]][j-1], s1=sec[i][j-1], s2=sec[f[i][j-1]][j-1]; fst[i][j]=max(f1, f2); get_sec(sec[i][j], f1, f2, s1, s2, fst[i][j]); &#125;&#125;inline long long query(int a, int b, long long dis)&#123; if(deep[a]&lt;deep[b]) swap(a, b); long long fsa=-1, sca=-1, fsb=-1, scb=-1; int d=deep[a]-deep[b]; for(RG int i=0;(1&lt;&lt;i)&lt;=d;i++) &#123; if((1&lt;&lt;i)&amp;d) &#123; long long tmp=sca; get_sec(sca, fsa, fst[a][i], tmp, sec[a][i], max(fsa, fst[a][i])); fsa=max(fsa, fst[a][i]); a=f[a][i]; &#125; &#125; if(a==b) &#123; long long tmp=sca; get_sec(sca, fsa, fsb, tmp, scb, max(fsa, fsb)); if(dis==max(fsa, fsb)) return value-sca+dis; else return value-max(fsa, fsb)+dis; &#125; for(RG int i=17;~i;i--) &#123; if(f[a][i]!=f[b][i]) &#123; long long tmp=sca; get_sec(sca, fsa, fst[a][i], tmp, sec[a][i], max(fsa, fst[a][i])); fsa=max(fsa, fst[a][i]); a=f[a][i]; tmp=scb; get_sec(scb, fsb, fst[b][i], tmp, sec[b][i], max(fsb, fst[b][i])); fsb=max(fsb, fst[b][i]); b=f[b][i]; &#125; &#125; long long tmp=sca; get_sec(sca, fsa, fst[a][0], tmp, sec[a][0], max(fsa, fst[a][0])); fsa=max(fsa, fst[a][0]); a=f[a][0]; tmp=scb; get_sec(scb, fsb, fst[b][0], tmp, sec[b][0], max(fsb, fst[b][0])); fsb=max(fsb, fst[b][0]); b=f[b][0]; tmp=sca; get_sec(sca, fsa, fsb, tmp, scb, max(fsa, fsb)); if(dis==max(fsa, fsb)) return value-sca+dis; else return value-max(fsa, fsb)+dis;&#125;const long long I(9223372036854775807ll);int main()&#123; n=read&lt;int&gt;(); m=read&lt;int&gt;(); for(RG int i=1;i&lt;=m;i++) edg[i].from=read&lt;int&gt;(), edg[i].to=read&lt;int&gt;(), edg[i].dis=read&lt;long long&gt;(); sort(edg+1, edg+m+1, cmp); mst(); init(); ANS=I; for(RG int i=1;i&lt;=m;i++) if(!use[i]) ANS=min(ANS, query(edg[i].from, edg[i].to, edg[i].dis)); printf("%lld\n", ANS); return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>CJOJ</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Hexo以及设置Blog]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%AE%89%E8%A3%85Hexo%E4%BB%A5%E5%8F%8A%E8%AE%BE%E7%BD%AEBlog%2F</url>
    <content type="text"><![CDATA[安装：1234567sudo apt-get install nodejssudo apt-get install nodejs-legacysudo apt-get install npmsudo npm install hexo -gsudo npm install hexo cli -gsudo npm installsudo npm install --save hexo-deployer-gith 然后把文件拷过来即可。]]></content>
      <tags>
        <tag>帮助</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-06考试]]></title>
    <url>%2F2018%2F02%2F06%2F2018-02-06%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[题目： T1 CJOJ1437 T2 CJOJ2663 T3 CJOJ2403 题目在这里 题解在这里 代码：T1 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(5000010);char a[maxn], b[maxn]; int len, n, pos;struct node &#123; char c; int id; &#125; q[maxn];int head, tail;inline void push(int x)&#123; while(head&lt;=tail&amp;&amp;q[tail].c&gt;a[x]) tail--; q[++tail]=(node)&#123;a[x], x&#125;; while(q[head].id&lt;=pos) head++;&#125;int main()&#123; scanf("%s", a); len=strlen(a); n=len-read&lt;int&gt;(); head=1; tail=0; pos=-1; for(RG int i=0;i&lt;len-n+1;i++) push(i); for(RG int i=len-n+1;i&lt;len;i++) &#123; char ans=q[head].c; pos=q[head].id; b[i-(len-n+1)]=ans; push(i); &#125; char ans=q[head].c; b[n-1]=ans; int p=0; while((!(b[p]^48)) &amp;&amp; p&lt;n-1) p++; puts(b+p); return 0;&#125; T2 :1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(250010);int n, x[maxn], y[maxn];long long l;priority_queue&lt;int&gt; heap;int main()&#123; n=read&lt;int&gt;(); for(RG int i=1;i&lt;=n;i++) x[i]=read&lt;int&gt;(); for(RG int i=1;i&lt;=n;i++) y[i]=read&lt;int&gt;(); for(RG int i=1;i&lt;=n;i++) &#123; l+=x[i]; heap.push(y[i]); l-=y[i]; if(l&lt;0) &#123; l+=heap.top(); heap.pop(); &#125; &#125; printf("%d\n", heap.size()); return 0;&#125; T3 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define for_edge(i, x) for(RG int i=head[x];i;i=e[i].next)#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010), maxm(300010);struct edge&#123; int next, to; long long dis;&#125; e[maxn &lt;&lt; 1];int head[maxn], e_num;inline void add_edge(int from, int to, long long dis)&#123; e[++e_num]=&#123;head[from], to, dis&#125;; head[from]=e_num;&#125;struct edge_k &#123; int from, to; long long dis; &#125; edg[maxm];inline bool cmp(const edge_k &amp;a, const edge_k &amp;b) &#123; return a.dis&lt;b.dis; &#125;int fa[maxn], n, m;long long value; bool use[maxm];inline int find(const int &amp;x) &#123; return fa[x] == x ? x : fa[x]=find(fa[x]); &#125;inline void mst()&#123; long long ans=0; for(RG int i=1;i&lt;=n;i++) fa[i]=i; for(RG int i=1;i&lt;=m;i++) &#123; int x=find(edg[i].from), y=find(edg[i].to); if(x!=y) &#123; fa[max(x, y)]=min(x, y); ans+=edg[i].dis; use[i]=true; add_edge(edg[i].from, edg[i].to, edg[i].dis); add_edge(edg[i].to, edg[i].from, edg[i].dis); &#125; &#125; value = ans;&#125;long long fst[maxn][18], sec[maxn][18], ANS=0;int f[maxn][18], deep[maxn];inline void dfs(int x)&#123; for_edge(i, x) &#123; int to=e[i].to; long long ds=e[i].dis; if(to==f[x][0]) continue; f[to][0]=x; fst[to][0]=sec[to][0]=ds; deep[to]=deep[x]+1; dfs(to); &#125;&#125;inline void get_sec(long long &amp;sec, long long a, long long b, long long c, long long d, long long _max)&#123; if(a&lt;_max) sec=a; if(b&lt;_max) sec=max(sec, b); if(c&lt;_max) sec=max(sec, c); if(d&lt;_max) sec=max(sec, d);&#125;inline void init()&#123; dfs(1); for(RG int j=1;j&lt;18;j++) for(RG int i=1;i&lt;=n;i++) &#123; f[i][j]=f[f[i][j-1]][j-1]; long long f1=fst[i][j-1], f2=fst[f[i][j-1]][j-1], s1=sec[i][j-1], s2=sec[f[i][j-1]][j-1]; fst[i][j]=max(f1, f2); get_sec(sec[i][j], f1, f2, s1, s2, fst[i][j]); &#125;&#125;inline long long query(int a, int b, long long dis)&#123; if(deep[a]&lt;deep[b]) swap(a, b); long long fsa=-1, sca=-1, fsb=-1, scb=-1; int d=deep[a]-deep[b]; for(RG int i=0;(1&lt;&lt;i)&lt;=d;i++) &#123; if((1&lt;&lt;i)&amp;d) &#123; long long tmp=sca; get_sec(sca, fsa, fst[a][i], tmp, sec[a][i], max(fsa, fst[a][i])); fsa=max(fsa, fst[a][i]); a=f[a][i]; &#125; &#125; if(a==b) &#123; long long tmp=sca; get_sec(sca, fsa, fsb, tmp, scb, max(fsa, fsb)); if(dis==max(fsa, fsb)) return value-sca+dis; else return value-max(fsa, fsb)+dis; &#125; for(RG int i=17;~i;i--) &#123; if(f[a][i]!=f[b][i]) &#123; long long tmp=sca; get_sec(sca, fsa, fst[a][i], tmp, sec[a][i], max(fsa, fst[a][i])); fsa=max(fsa, fst[a][i]); a=f[a][i]; tmp=scb; get_sec(scb, fsb, fst[b][i], tmp, sec[b][i], max(fsb, fst[b][i])); fsb=max(fsb, fst[b][i]); b=f[b][i]; &#125; &#125; long long tmp=sca; get_sec(sca, fsa, fst[a][0], tmp, sec[a][0], max(fsa, fst[a][0])); fsa=max(fsa, fst[a][0]); a=f[a][0]; tmp=scb; get_sec(scb, fsb, fst[b][0], tmp, sec[b][0], max(fsb, fst[b][0])); fsb=max(fsb, fst[b][0]); b=f[b][0]; tmp=sca; get_sec(sca, fsa, fsb, tmp, scb, max(fsa, fsb)); if(dis==max(fsa, fsb)) return value-sca+dis; else return value-max(fsa, fsb)+dis;&#125;const long long I(9223372036854775807ll);int main()&#123; n=read&lt;int&gt;(); m=read&lt;int&gt;(); for(RG int i=1;i&lt;=m;i++) edg[i].from=read&lt;int&gt;(), edg[i].to=read&lt;int&gt;(), edg[i].dis=read&lt;long long&gt;(); sort(edg+1, edg+m+1, cmp); mst(); init(); ANS=I; for(RG int i=1;i&lt;=m;i++) if(!use[i]) ANS=min(ANS, query(edg[i].from, edg[i].to, edg[i].dis)); printf("%lld\n", ANS); return 0;&#125; 总结 :]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-04考试]]></title>
    <url>%2F2018%2F02%2F06%2F2018-02-04%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[题目： T1 Luogu P1182 T2 CJOJ1101 T3 Luogu P1852 题目在这里 题解在这里 代码：T1 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T = int&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(100010);int n, k;long long a[maxn], _max, s[maxn];inline bool check(long long mid)&#123; RG int l=1, tmpk=1; for(RG int i=2;i&lt;=n;i++) &#123; if(s[i-1]-s[l-1]&lt;=mid &amp;&amp; s[i]-s[l-1]&gt;mid) &#123; l=i; tmpk++; if(tmpk&gt;k) return false; &#125; &#125; return true;&#125;int main()&#123; file(seqa); n=read(); k=read(); for(RG int i=1;i&lt;=n;i++) s[i]=s[i-1]+(a[i]=read&lt;long long&gt;()), _max=max(_max, a[i]); if(k==n) return printf("%lld\n", _max)&amp;0; if(k==1) return printf("%lld\n", s[n])&amp;0; long long l=_max, r=s[n]; while(l&lt;r) &#123; long long mid=(l+r)&gt;&gt;1; bool ans=check(mid); if(ans) r=mid; else l=mid+1; &#125; printf("%lld\n", r); return 0;&#125; T2 :12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T = int&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;const int maxn(110);int f[maxn][maxn], d1[maxn], d2[maxn], n, m;inline bool check(int mid)&#123; clear(f, -127/3); f[0][0]=0; for(RG int i=1;i&lt;=n;i++) for(RG int j=0;j&lt;=m;j++) for(RG int k=0;k&lt;=j;k++) if(mid&gt;=d1[i]*k) f[i][j]=max(f[i][j], f[i-1][j-k]+(mid-d1[i]*k)/d2[i]); return f[n][m]&gt;=m;&#125;int main()&#123; n=read(); m=read(); for(RG int i=1;i&lt;=n;i++) d1[i]=read(), d2[i]=read(); int l=1, r=1e6; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; bool ans=check(mid); if(ans) r=mid; else l=mid+1; &#125; printf("%d\n", r); return 0;&#125; T3 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));namespace std &#123; template&lt;&gt; inline void swap(int &amp;x, int &amp;y) &#123; y^=x^=y^=x; &#125; &#125;using namespace std;template&lt;typename T = long long&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;struct node &#123; long long a, b, c, s1, s2; &#125; p, q, rtp, rtq;inline node turn(node &amp;&amp;x)&#123; if(x.a&gt;x.b) swap(x.a, x.b); if(x.a&gt;x.c) swap(x.a, x.c); if(x.b&gt;x.c) swap(x.c, x.b); x.s1=x.b-x.a; x.s2=x.c-x.b; return x;&#125;inline pair&lt;node, int&gt; get_root(const node &amp;x)&#123; int depth=0; int a=x.a, b=x.b, c=x.c, s1=x.s1, s2=x.s2; while(s1!=s2) &#123; if(s1&lt;s2) &#123; depth+=s2/s1; s2%=s1; if(s2==0) s2=s1, depth--; b=c-s2; a=b-s1; &#125; else &#123; depth+=s1/s2; s1%=s2; if(s1==0) s1=s2, depth--; b=a+s1; c=b+s2; &#125; &#125; return &#123;&#123;a, b, c, s1, s2&#125;, depth&#125;;&#125;inline node jump(const node &amp;x, int depth)&#123; int a=x.a, b=x.b, c=x.c, s1=x.s1, s2=x.s2, dep=0; while(s1!=s2) &#123; if(s1&lt;s2) &#123; dep+=s2/s1; if(dep&gt;depth) &#123; int tmp=depth-dep+s2/s1; s2-=s1*tmp; b=c-s2; a=b-s1; return &#123;a, b, c, s1, s2&#125;; &#125; else &#123; s2%=s1; if(s2==0) s2=s1, dep--; b=c-s2; a=b-s1; &#125; &#125; else &#123; dep+=s1/s2; if(dep&gt;depth) &#123; int tmp=depth-dep+s1/s2; s1-=s2*tmp; b=a+s1; c=b+s2; return &#123;a, b, c, s1, s2&#125;; &#125; else &#123; s1%=s2; if(s1==0) s1=s2, dep--; b=a+s1; c=b+s2; &#125; &#125; &#125; return &#123;a, b, c, s1, s2&#125;;&#125;bool operator == (const node &amp;a, const node &amp;b) &#123; return a.a==b.a&amp;&amp;a.b==b.b&amp;&amp;a.c==b.c; &#125;int dp, dq;int main()&#123; p=turn(&#123;read(), read(), read(), 0, 0&#125;); q=turn(&#123;read(), read(), read(), 0, 0&#125;); auto t=get_root(p); rtp=t.first; dp=t.second; t=get_root(q); rtq=t.first; dq=t.second; if(!(rtp==rtq)) &#123; puts("NO"); return 0; &#125; int ans=abs(dp-dq); if(dp&gt;dq) p=jump(p, dp-dq), dp=dq; else q=jump(q, dq-dp), dq=dp; int l=0, r=dp; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; node x=jump(p, mid), y=jump(q, mid); if(x==y) r=mid; else l=mid+1; &#125; printf("YES\n%d\n", ans+(r&lt;&lt;1)); return 0;&#125; 总结 :这一次，骗分达到了极限，自认为比较满意了。(逃)]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人模板]]></title>
    <url>%2F2018%2F02%2F06%2F%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[矩阵主要实现矩乘 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;/*if you want to use "int" to build an Matrix, you can * *int n, m; *... *const int N(n), M(m); *Matrix&lt;N, M&gt; matrix; * */template&lt;int N, int M&gt;struct Matrix&#123; private: int a[N][M]; int MOD; public: Matrix(int MO) : MOD(MO) &#123; clear(a, 0); &#125; int *operator [] (int index) &#123; return a[index]; &#125; template&lt;int K&gt; Matrix&lt;N, K&gt; operator * (Matrix&lt;M, K&gt; &amp;b) &#123; Matrix&lt;N, K&gt; c(MOD); for(RG int i=0;i&lt;N;i++) for(RG int j=0;j&lt;M;j++) for(RG int k=0;k&lt;K;k++) c[i][k]=(c[i][k]+a[i][j]*b[j][k])%MOD; return c; &#125;&#125;;int main()&#123; return 0;&#125; TreesSplay Splay大法好 替罪羊树 跑得比Splay快n倍 Treap: 跑得比Splay慢… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418#ifndef BALANCE_TREE_HPP#define BALANCE_TREE_HPP#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;namespace Balance_tree&#123; class Splay &#123; private: struct node &#123; int val, size; node *fa, *son[2]; node(int v, node *f):fa(f), val(v)&#123; son[0]=son[1]=NULL; size=1; &#125; &#125;*root; inline int size(node *x) &#123; return x==NULL?0:x-&gt;size; &#125; inline void update(node *x) &#123; x-&gt;size=size(x-&gt;son[0])+size(x-&gt;son[1])+1; &#125; inline bool son(node *f, node *x) &#123; return f-&gt;son[1]==x; &#125; inline int cmp(node *t, int x) &#123; return x &lt; t-&gt;val ? 0 : (x == t-&gt;val ? -1 : 1); &#125; inline void rotate(node *x) &#123; node *f=x-&gt;fa, *g=f-&gt;fa; bool a=son(f, x), b=!a; f-&gt;son[a]=x-&gt;son[b]; if(x-&gt;son[b]) x-&gt;son[b]-&gt;fa=f; x-&gt;son[b]=f; f-&gt;fa=x; x-&gt;fa=g; if(g) g-&gt;son[son(g, f)]=x; else root=x; update(f); update(x); &#125; inline void splay(node *x, node *r=NULL) &#123; for(;x-&gt;fa!=r;rotate(x)) &#123; node *f=x-&gt;fa, *g=f-&gt;fa; if(g!=r) rotate((son(g, f)^son(f, x) ? x : f)); &#125; &#125; inline void print(node *x) &#123; if(!x) return; print(x-&gt;son[0]); printf("%d ", x-&gt;val); print(x-&gt;son[1]); &#125; public: inline void insert(int x) &#123; if(!root) &#123; root = new node(x, NULL); return; &#125; node *t=root, *f=NULL; while(t) &#123; int val=t-&gt;val; f=t; t=t-&gt;son[x&gt;val]; &#125; t=new node(x, f); if(f) f-&gt;son[x&gt;f-&gt;val]=t; splay(t); &#125; inline void find(int x) &#123; node *t=root; while(t-&gt;val!=x &amp;&amp; t) t=t-&gt;son[x&gt;t-&gt;val]; if(t) splay(t); &#125; inline void erase(int x) &#123; find(x); node *t=root-&gt;son[0], *del=root; if(!t) root=root-&gt;son[1]; else &#123; while(t-&gt;son[1]) t=t-&gt;son[1]; splay(t, root); root=t; root-&gt;son[1]=del-&gt;son[1]; if(root-&gt;son[1]) root-&gt;son[1]-&gt;fa=root; &#125; delete del; if(root) root-&gt;fa=NULL; update(root); &#125; inline int k_th(int k) &#123; node *t=root; while(t) &#123; int s = size(t-&gt;son[0])+1; if(k&gt;s) t=t-&gt;son[1], k-=s; else if(k==s) return t-&gt;val; else t=t-&gt;son[0]; &#125; return -1; &#125; inline int rank(int x) &#123; int ans=0; node *t=root; while(t) &#123; int d=cmp(t, x); if(d==1) ans+=size(t-&gt;son[0])+1; if(d==-1) d=0; t=t-&gt;son[d]; &#125; return ans+1; &#125; inline int suc(int x, int k) //1-&gt;suc, 0-&gt;pre &#123; int res=-1; node *t=root; int q=k, c=q^1; while(t) &#123; int d=cmp(t, x); if(d==c) res=t-&gt;val; if(d==-1) d=q; t=t-&gt;son[d]; &#125; return res; &#125; inline void print() &#123; print(root); &#125; &#125;; const int maxn(); const int alpha(0.75); class scapetree &#123; private: struct node &#123; int val, size; node *son[2]; int cmp(int x) const &#123; return x &lt; val ? 0 : ( x== val ? -1 : 1); &#125; node(int v=0) : val(v), size(1) &#123; son[0]=son[1]=NULL; &#125; &#125;*root, *xl[maxn]; int tot; void print(node *r) &#123; if(r==NULL) return; print(r-&gt;son[0]); xl[++tot]=r; print(r-&gt;son[1]); &#125; int size(node *t) &#123; return t==NULL?0:t-&gt;size; &#125; void update(node *t) &#123; t-&gt;size=size(t-&gt;son[0])+size(t-&gt;son[1])+1; &#125; void rebuild(node *&amp;rt, int l, int r) &#123; if(l&gt;r) &#123; rt=NULL; return; &#125; int mid=(l+r)&gt;&gt;1; rt=xl[mid]; rebuild(rt-&gt;son[0], l, mid-1); rebuild(rt-&gt;son[1], mid+1, r); update(rt); &#125; void insert(node *&amp;r, int x) &#123; if(r==NULL) r=new node(x); else &#123; int t=r-&gt;cmp(x); if(t==-1) t=0; insert(r-&gt;son[t], x); &#125; update(r); &#125; void scape(node *&amp;r, int x) &#123; if(r==NULL) return; int d=r-&gt;cmp(x); if(d==-1) return; if(size(r-&gt;son[d])&gt;r-&gt;size*alpha) &#123; tot=0; print(r); rebuild(r, 1, tot); &#125; else scape(r-&gt;son[d], x); &#125; void erase(node *&amp;r, int x) &#123; int d=r-&gt;cmp(x); if(d==-1) &#123; if((!r-&gt;son[0])&amp;&amp;(!r-&gt;son[1])) r=NULL; else &#123; tot=0; print(r-&gt;son[0]); print(r-&gt;son[1]); delete r; r=NULL; rebuild(r, 1, tot); &#125; &#125; else erase(r-&gt;son[d], x); if(r) update(r); &#125; public: scapetree()&#123; root=NULL; &#125; void insert(int x) &#123; insert(root, x); scape(root, x); &#125; void erase(int x) &#123; erase(root, x); &#125; int k_th(int k) &#123; node *t=root; while(t) &#123; int s=size(t-&gt;son[0])+1; if(s==k) return t-&gt;val; if(s&lt;k) k-=s, t=t-&gt;son[1]; else t=t-&gt;son[0]; &#125; return -1; &#125; int rank(int x) &#123; int ans=0; node *t=root; while(t) &#123; int d=t-&gt;cmp(x); if(d==1) ans+=size(t-&gt;son[0])+1; if(d==-1) d=0; t=t-&gt;son[d]; &#125; return ans+1; &#125; int suc(int x) &#123; int res=-1; node *t=root; while(t) &#123; int d=t-&gt;cmp(x); if(d==0) res=t-&gt;val; if(d==-1) d=1; t=t-&gt;son[d]; &#125; return res; &#125; int pre(int x) &#123; int res=-1; node *t=root; while(t) &#123; int d=t-&gt;cmp(x); if(d==1) res=t-&gt;val; if(d==-1) d=0; t=t-&gt;son[d]; &#125; return res; &#125; &#125;; class Treap &#123; private: struct node &#123; int val, ran, size; node *son[2]; node(int k=0) :val(k) &#123; ran=rand(); son[0]=son[1]=NULL; size=1; &#125; int cmp(int k) &#123; return k &lt; val ? 0 : ( k == val ? -1 : 1 ); &#125; &#125;*root; int size(node *t) &#123; return t == NULL ? 0 : t-&gt;size; &#125; void update(node *t) &#123; t -&gt; size = size(t -&gt; son[0]) + size(t -&gt; son[1]) + 1; &#125; void rotate(node *&amp;t, int f) &#123; node *son=t-&gt;son[f^1]; t-&gt;son[f^1]=son-&gt;son[f]; son-&gt;son[f]=t; update(t); update(son); t=son; &#125; void insert(node *&amp;t, int value) &#123; if(t==NULL) t=new node(value); else &#123; int f=(t-&gt;val&lt;=value); insert(t-&gt;son[f], value); if((t-&gt;son[f]-&gt;ran) &gt; (t-&gt;ran)) rotate(t, f^1); &#125; update(t); &#125; void erase(node *&amp;t, int value) &#123; int f=t-&gt;cmp(value); if(f==-1) &#123; node *t1=t; if(t-&gt;son[0]==NULL) &#123; t=t-&gt;son[1]; delete t1; t1=NULL; &#125; else if(t-&gt;son[1]==NULL) &#123; t=t-&gt;son[0]; delete t1; t1=NULL; &#125; else &#123; int f2=(t-&gt;son[0]-&gt;ran &gt; t-&gt;son[1]-&gt;ran); rotate(t, f2); erase(t-&gt;son[f2], value); &#125; &#125; else erase(t-&gt;son[f], value); if(t!=NULL) update(t); &#125; public: Treap()&#123; root=NULL; srand(time(NULL)); &#125; void insert(int val) &#123; insert(root, val); &#125; void erase(int val) &#123; erase(root, val); &#125; int k_th(int k) &#123; node *t=root; while(t) &#123; int s=size(t-&gt;son[0])+1; if(s==k) return t-&gt;val; if(s&lt;k) k-=s, t=t-&gt;son[1]; else t=t-&gt;son[0]; &#125; return -1; &#125; int rank(int x) &#123; int ans=0; node *t=root; while(t) &#123; int d=t-&gt;cmp(x); if(d==1) ans+=size(t-&gt;son[0])+1; if(d==-1) d=0; t=t-&gt;son[d]; &#125; return ans+1; &#125; int suc(int x) &#123; int res=-1; node *t=root; while(t) &#123; int d=t-&gt;cmp(x); if(d==0) res=t-&gt;val; if(d==-1) d=1; t=t-&gt;son[d]; &#125; return res; &#125; int pre(int x) &#123; int res=-1; node *t=root; while(t) &#123; int d=t-&gt;cmp(x); if(d==1) res=t-&gt;val; if(d==-1) d=0; t=t-&gt;son[d]; &#125; return res; &#125; &#125;;&#125;#endif 玄学读入方法$1$12345678910111213141516#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125; 方法$2$12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "rb", stdin);freopen(#x".out", "w+", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;namespace quickIO&#123; const int MAXS = (1&lt;&lt;21); char buf[MAXS], *p; int len; inline int read() &#123; int data=0, w=1; char ch=*p++; while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')&amp;&amp;p-buf&lt;len&amp;&amp;(*p)) ch=*p++; if(ch=='-') w=-1, ch=*p++; while(ch&gt;='0'&amp;&amp;ch&lt;='9'&amp;&amp;p-buf&lt;len&amp;&amp;(*p)) data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=*p++; return data*w; &#125; void init() &#123; len = fread(buf,1,MAXS,stdin); buf[len] = '\0'; p=buf; &#125;&#125;using namespace quickIO; 树剖神秘非递归1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define RG register#define file(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);#define clear(x, y) memset(x, y, sizeof(x));using namespace std;template&lt;typename T = int&gt;inline T read()&#123; T data=0, w=1; char ch=getchar(); while(ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1, ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') data=(data&lt;&lt;3)+(data&lt;&lt;1)+(ch^48), ch=getchar(); return data*w;&#125;struct edge &#123; int next, to; &#125; e[maxn &lt;&lt; 1];int head[maxn], e_num, now[maxn], fa[maxn], size[maxn], heavy[maxn], pos[maxn], belong[maxn], cnt_pos[maxn], out_pos[maxn], cnt_node;bool dk[maxn];inline void add_edge(int from, int to) &#123; e[++e_num]=&#123;head[from], to&#125;; head[from]=e_num; &#125;inline void split(int root)&#123; // 记得在初始化时加 size[i]=1; clear(now, -1); RG int i=root; while(i) &#123; do &#123; now[i]=(~now[i]) ? (e[now[i]].next) : (head[i]); &#125; while(fa[i]==e[now[i]].to &amp;&amp; now[i]); if(now[i]) &#123; fa[e[now[i]].to]=i; i=e[now[i]].to; &#125; else &#123; if(fa[i]) size[fa[i]]+=size[i], heavy[fa[i]]=(size[heavy[fa[i]]] &lt; size[i] ? i : heavy[fa[i]]); i=fa[i]; &#125; &#125; i=root; belong[i]=i; pos[i]=1; cnt_pos[1]=i; cnt_node=1; clear(now, -1); while(i) &#123; int k=heavy[i]; if(!dk[i]) &#123; dk[i]=true; if(!k) out_pos[i]=cnt_node, i=fa[i]; else pos[k]=++cnt_node, cnt_pos[cnt_node]=k, belong[k]=belong[i], i=k; continue; &#125; do &#123; now[i]=(~now[i]) ? (e[now[i]].next) : (head[i]); &#125; while((fa[i]==e[now[i]].to || k==e[now[i]].to) &amp;&amp; now[i]); if(now[i]) &#123; pos[i=e[now[i]].to]=++cnt_node; cnt_pos[cnt_node]=i; belong[i]=i; &#125; else out_pos[i]=cnt_node, i=fa[i]; &#125;&#125;int main()&#123; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
